<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>可持久化数据结构学习笔记</title>
    <url>/2024/09/19/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>水母中学好耶。</p>
<h3 id="几个基础概念"><a class="markdownIt-Anchor" href="#几个基础概念"></a> 几个基础概念</h3>
<ol>
<li>
<p>可持久化：对于一个数据结构，需要维护其所有的历史版本</p>
</li>
<li>
<p>部分可持久化：对于一个历史版本，允许访问，不能修改</p>
</li>
<li>
<p>完全可持久化：对于一个历史版本，可访问可修改</p>
</li>
<li>
<p>（这个以前完全不知道）Confluent persistent（我的翻译：合并式可持久化）：允许合并历史版本，不太能维护（不常见）</p>
</li>
</ol>
<h3 id="可持久化线段树"><a class="markdownIt-Anchor" href="#可持久化线段树"></a> 可持久化线段树</h3>
<p>最朴素的，每次复制一整棵树。</p>
<p>然而空间和时间都无法接受。</p>
<p>于是，我们考虑优化。</p>
<p>有一张直观的图：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/anxbw8me.png" alt></p>
<p>注意到，每次最多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span></span></span></span> 个节点被改了。没改的连到历史版本对应节点，于是解决。</p>
<p>每次要新开根节点，一是要修改，二是操作时方便找。</p>
<p>空复时复都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 是操作次数），可以接受。</p>
<p>这种方法被称作“path copy”，但中文译名暂无。我觉得可以译为“懒惰连边”。</p>
<p>下面的代码是教练课件中的实现代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d,<span class="type">int</span> &amp;rt,<span class="type">int</span> lrt)</span></span>&#123;</span><br><span class="line">  rt=++tnt;t[rt]=t[lrt];</span><br><span class="line">  <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">    <span class="comment">//处理</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(mid&gt;=d)<span class="built_in">Insert</span>(l,mid,d,t[rt].lson,t[lrt].lson);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">Insert</span>(mid+<span class="number">1</span>,r,d,t[rt].rson,t[lrt].rson);</span><br><span class="line">  <span class="built_in">update</span>(rt,l,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="标记永久化"><a class="markdownIt-Anchor" href="#标记永久化"></a> 标记永久化</h4>
<p>区间修改，我们会打懒标记 lazy-tag。</p>
<p>然而可持久化线段树下放的话，很麻烦。</p>
<p>这时我们就可以用“标记永久化”，顾名思义，就是把标记打在节点上后不进行下放，而是在查询这个节点的值的<br>
时候再考虑这个标记。然后就解决了。</p>
<h4 id="一道例题"><a class="markdownIt-Anchor" href="#一道例题"></a> 一道例题</h4>
<p>这个问题能直观地看出可持久化有多好用。</p>
<p>区间第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 小值问题：给定一个序列，多次查询其中某个区间的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 小值。</p>
<p>首先想到二分。</p>
<p>然后 <code>check</code> 函数统计有多少个数小于等于它。</p>
<p>可以用整体二分或者可持久化线段树实现。</p>
<ol>
<li>整体二分</li>
</ol>
<p>优点：空间线性，支持单点修改</p>
<p>缺点：离线，复杂度多个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\log</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span></span></span></span>，难理解</p>
<p>没学过，不细讲。</p>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo><msup><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msup><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((n+m)\log^2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.148448em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984479999999999em;"><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>。</p>
<ol start="2">
<li>可持久化线段树</li>
</ol>
<p>优点：在线，复杂度少个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\log</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span></span></span></span>，好写</p>
<p>缺点：空间多个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\log</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span></span></span></span>，不能修改</p>
<p>从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 建出每个前缀的权值线段树，然后用可持久化线段树。</p>
<p>查询就直接线段树上二分，再用前缀和基础知识。</p>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((n+m)\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p>
<h5 id="优劣对比"><a class="markdownIt-Anchor" href="#优劣对比"></a> 优劣对比：</h5>
<p>各自优一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\log</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span></span></span></span>，所以要具体题目具体分析。</p>
<p>但是可持久化线段树的支持在线是真的实用。</p>
<h3 id="一些可持久化数据结构"><a class="markdownIt-Anchor" href="#一些可持久化数据结构"></a> 一些可持久化数据结构</h3>
<h4 id="可持久化-trie-树"><a class="markdownIt-Anchor" href="#可持久化-trie-树"></a> 可持久化 trie 树</h4>
<p><s>观察到</s> trie 树是树。</p>
<p>所以可以用 path copy。</p>
<h4 id="可持久化平衡树"><a class="markdownIt-Anchor" href="#可持久化平衡树"></a> 可持久化平衡树</h4>
<p>treap 不太能（也许是不能）可持久化。</p>
<p>于是，我们可以想到 无旋/分裂/FHQ treap。</p>
<p>这样，就可以用 path copy 了。</p>
<h4 id="可持久化可并堆"><a class="markdownIt-Anchor" href="#可持久化可并堆"></a> 可持久化可并堆</h4>
<p>不知道这是啥。教练说可以用左偏树，也不知道是啥。确实需要多学一些知识。</p>
<p>用了左偏树，还是照抄 path copy。</p>
<p>我们会发现，path copy 不是一点的好用，而是常用、非常好用、好理解、好写的可持久化神兵。</p>
<h4 id="其他的可持久化数据结构"><a class="markdownIt-Anchor" href="#其他的可持久化数据结构"></a> 其他的可持久化数据结构</h4>
<p>复杂度不依赖均摊（反例：splay）的，大多数都可以用 path copy。</p>
<p>为什么类似 splay 的数据结构不能？</p>
<p>因为均摊。</p>
<p>如果我出个数据，疯狂卡你的 splay，而且每次历史版本都访问你被卡的版本，你就 TLE 了。</p>
<p>当然，也不是说他们不行，部分依赖均摊的也能用 path copy。只不过只能做到部分可持久化。</p>
<h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3>
<ol>
<li><a href="https://www.luogu.com.cn/problem/P3919">P3919</a></li>
</ol>
<p>模版题，结合代码讲。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> esp 1e-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 999999999999999999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b,g) for(LL i=a;i&lt;=b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rem(i,a,b,g) for(LL i=a;i&gt;=b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> repn(i,a,b,g) for(LL i=a;i&lt;b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> remn(i,a,b,g) for(LL i=a;i&gt;b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;LL,LL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mkp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i128 LL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//比较奇怪的一点：要用快读快写。不知道为啥。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(i128 &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i128 f=<span class="number">1</span>;</span><br><span class="line">	x=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writing</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">10</span>)<span class="built_in">writing</span>(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		x=-x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">writing</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">LL n,m,tot,head[N],a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	LL l,r,ls,rs,val;<span class="comment">//区间左右端点，左右儿子，值</span></span><br><span class="line">&#125;t[N*<span class="number">30</span>];<span class="comment">//因为很多版本，开大一点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">newnode</span><span class="params">(LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[++tot]=(node)&#123;l,r,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line">&#125;<span class="comment">//动态开点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(LL k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL l=t[k].l,r=t[k].r;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[k].val=a[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LL mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	t[k].ls=<span class="built_in">newnode</span>(l,mid);</span><br><span class="line">	t[k].rs=<span class="built_in">newnode</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">build</span>(t[k].ls);</span><br><span class="line">	<span class="built_in">build</span>(t[k].rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">newver</span><span class="params">(LL k,LL x)</span><span class="comment">//新版本</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!k)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;t[k].l||x&gt;t[k].r)<span class="keyword">return</span> k;</span><br><span class="line">	LL p=<span class="built_in">newnode</span>(t[k].l,t[k].r);</span><br><span class="line">	t[p]=t[k];</span><br><span class="line">	t[p].ls=<span class="built_in">newver</span>(t[k].ls,x);</span><br><span class="line">	t[p].rs=<span class="built_in">newver</span>(t[k].rs,x);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(LL k,LL x,LL val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[k].l&gt;x||t[k].r&lt;x)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(t[k].l==x&amp;&amp;x==t[k].r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[k].val=val;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">modify</span>(t[k].ls,x,val);</span><br><span class="line">	<span class="built_in">modify</span>(t[k].rs,x,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(LL k,LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[k].l==x&amp;&amp;x==t[k].r)<span class="keyword">return</span> t[k].val;</span><br><span class="line">	LL mid=t[k].l+t[k].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)<span class="keyword">return</span> <span class="built_in">query</span>(t[k].ls,x);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">query</span>(t[k].rs,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>)<span class="built_in">read</span>(a[i]);</span><br><span class="line">	head[<span class="number">0</span>]=<span class="built_in">newnode</span>(<span class="number">1</span>,n);</span><br><span class="line">	<span class="built_in">build</span>(head[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LL ver,op,x,val;</span><br><span class="line">		<span class="built_in">read</span>(ver);</span><br><span class="line">		<span class="built_in">read</span>(op);</span><br><span class="line">		<span class="built_in">read</span>(x);</span><br><span class="line">		head[i]=<span class="built_in">newver</span>(head[ver],x);</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">read</span>(val);</span><br><span class="line">			<span class="built_in">modify</span>(head[i],x,val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">write</span>(<span class="built_in">query</span>(head[i],x));</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>确实很简单。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 多行，我还写了很多的 <code>#define</code>。</p>
<ol start="2">
<li><a href="https://www.luogu.com.cn/problem/P2839">P2839</a></li>
</ol>
<p>首先，我们得知道如何做某一次的询问。</p>
<p>一个常见的中位数套路是二分，把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">&lt;mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span></span></span></span> 的看做 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>，否则看做 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，若某段的和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\ge 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 则中位数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">\ge mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span></span></span></span>。</p>
<p>（如果看到“主席树”看不懂的，请牢记这就是可持久化权值线段树。）</p>
<p>用主席树维护，初始每个位置都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，按照权值大小从小到大变 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</p>
<p>然后，我们可以想到维护其前缀和。时间复杂度骤降。</p>
<p>询问时，如上去二分，然后找到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>b</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a-1,b-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 里权值最小的位置和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[c,d]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">d</span><span class="mclose">]</span></span></span></span> 中权值最大的位置。</p>
<p>再然后看看其区间和是否 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\ge 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo><msup><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msup><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((n+m)\log^2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.148448em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984479999999999em;"><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p>
<ol start="3">
<li><a href="https://uoj.ac/problem/218">火车管理</a></li>
</ol>
<p>感觉这个比 T2 简单诶。</p>
<p>先建立一个可持久化线段树，维护每个铁路每个时间的栈顶的吨位和栈顶火车的入栈时间。</p>
<p>再维护一颗线段树用来统计答案。</p>
<p>然后，就简单了：</p>
<ul>
<li>
<p><code>1</code> 操作：直接在答案线段树里询问即可。</p>
</li>
<li>
<p><code>2</code> 操作：可持久化线段树记录了入栈时间，所以我们删完后再用可持久化线段树查出当前入栈之前的栈顶的信<br>
息即可（可持久化的优势就体现了），然后在答案线段树上和可持久化线段树上修改。</p>
</li>
<li>
<p><code>3</code> 操作：在可持久化线段树上区间覆盖，区间覆盖算是个很基础的 trick 了，然后在答案线段树上修改。</p>
</li>
</ul>
<p>时间、空间复杂度均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p>
<ol start="4">
<li><a href="https://www.luogu.com.cn/problem/CF464E">CF464E</a></li>
</ol>
<p>请注意，截止该文章发布前，CF 开了 CF 导致洛谷 RMJ 无法正常使用。建议去 CF 原站提交（但是去原站也有被 CF 盾墙掉的问题）。等等吧。</p>
<p>首先明确，我们要用 dijkstra 求最短路。因为 SPFA 被卡了，详见<a href="https://www.luogu.com.cn/discuss/780372">https://www.luogu.com.cn/discuss/780372</a>。</p>
<p>对于最短路的长度，维护一棵线段树，下标为二进制位。</p>
<p>比较可以通过线段树二分找出首个不同的位，判断两个线段树结点是否相同可以用哈希（二进制，模数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1000000007</mn></mrow><annotation encoding="application/x-tex">1000000007</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">7</span></span></span></span> 即可，因为此时输出答案直接输出其哈希值）。</p>
<p>加 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 可以相当于把若干个连续的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 变成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，然后把下一位变成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
<p>教练课件上写“可以通过线段树上二分找出极长的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 连续段然后进行修改。”，感觉没直接搞简便。</p>
<p>使用可持久化线段树，从上一个版本继承过来，以保证不会超时。</p>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<p>可持久化线段树非常万金油，图论都能用。当然其他的也有用。限于篇幅和水平，还有很多（比如可持久化并查集）没放上来。</p>
<p>很感谢水母中学，以前只知道可持久化是“记录变化”，现在看看，不是这么简单的。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
        <category>可持久化</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>可持久化</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>2024 备战 CSP 模拟赛相关题解</title>
    <url>/2024/09/11/2024-%E5%A4%87%E6%88%98-CSP-%E6%A8%A1%E6%8B%9F%E8%B5%9B%E7%9B%B8%E5%85%B3%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>免责声明：视频加载因为是 github 托管，极慢，望请谅解</p>
<h3 id="csp-s-第一次模拟">CSP-S 第一次模拟</h3>
<h4 id="t1">T1</h4>
<p><video src="https://cppomstar.github.io/images/CSP-SR1T1.mp4" controls><a href="https://cppomstar.github.io/images/CSP-SR1T1.mp4">Video</a></video></p>
<p>整体思路：二分答案 <span class="math inline">\(+\)</span>
人类智慧剪枝。</p>
<p>二分四盏灯的最小耗电量之和。</p>
<p><code>che</code> 函数考虑左上角和右下角。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">↓以后网格上灯的叫法↓</th>
<th style="text-align: center;">↓以后网格上灯的叫法↓</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(a\)</span></td>
<td style="text-align: center;"><span class="math inline">\(b\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(c\)</span></td>
<td style="text-align: center;"><span class="math inline">\(d\)</span></td>
</tr>
</tbody>
</table>
<p>也就是说考虑 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(d\)</span>。<del>（其他任意两盏灯也可，本文以
<span class="math inline">\(a,d\)</span> 为参考讲解）</del>（UPD：zxz
讲到其他的会 TLE）</p>
<p>先两层循环枚举 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(d\)</span> 分配的电量，然后看 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(d\)</span>
还需要的亮度的较大值，和剩下多少电量可以分配。</p>
<p>如果剩下电量的一半小于 <span class="math inline">\(a\)</span> 和
<span class="math inline">\(d\)</span>
还需要的亮度的较大值，<code>continue</code> 掉（即无论怎么分配都没法使
<span class="math inline">\(a\)</span> 或 <span class="math inline">\(d\)</span> 亮度够）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LL adneed=<span class="built_in">max</span>(a-j/<span class="number">4</span>-i,d-i/<span class="number">4</span>-j);</span><br><span class="line">LL lef=mid-i-j;</span><br><span class="line"><span class="keyword">if</span>(lef/<span class="number">2</span>&lt;adneed)<span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
<p>然后，看 <span class="math inline">\(b\)</span> 和 <span class="math inline">\(c\)</span>
<strong>分别</strong>还需要多少电量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LL blef=<span class="built_in">max</span>(b-i/<span class="number">2</span>-j/<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line">LL clef=<span class="built_in">max</span>(c-i/<span class="number">2</span>-j/<span class="number">2</span>,<span class="number">0LL</span>);</span><br></pre></td></tr></table></figure>
<p>但此时我们会发现一个问题：<span class="math inline">\(b\)</span> 和
<span class="math inline">\(c\)</span> <strong>互相牵制</strong>。</p>
<p>考虑再套一层二分，二分给 <span class="math inline">\(b\)</span>
的电量（尽量使其接近 <code>blef</code>，留更多给 <span class="math inline">\(c\)</span>）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll=<span class="number">-1</span>;</span><br><span class="line">rr=lef+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(ll+<span class="number">1</span>&lt;rr)</span><br><span class="line">&#123;</span><br><span class="line">  mmiidd=ll+rr&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  LL t=mmiidd+(lef-mmiidd)/<span class="number">4</span>;</span><br><span class="line">  <span class="keyword">if</span>(t&gt;=blef)rr=mmiidd;</span><br><span class="line">  <span class="keyword">else</span> ll=mmiidd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后判断一下 <span class="math inline">\(b\)</span> 和 <span class="math inline">\(c\)</span> 的亮度是否合法，合法就
<code>return 1</code>。</p>
<p>时间复杂度 <span class="math inline">\(O(n^2log^2
n)\)</span>，理论要跑大约 <span class="math inline">\(6,561,000,000\)</span>
次（约二十秒）。时间复杂度非常劣，但跑的贼快，因为显然远远跑不满（大概只能跑到理论复杂度的
<span class="math inline">\(\frac{1}{200}\)</span>，即约 <span class="math inline">\(100\)</span> 毫秒（我的代码跑这题测试点最多用了
<span class="math inline">\(103\)</span>
毫秒）），所以比较推荐这种人类智慧做法。</p>
<p>为啥跑不满？</p>
<p><code>if(lef/2&lt;adneed)continue;</code> 拦下了很多不合法的。</p>
<p>而且内层二分的 <code>lef</code> 不会很高。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> esp 1e-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 999999999999999999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b,g) for(LL i=a;i&lt;=b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rem(i,a,b,g) for(LL i=a;i&gt;=b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> repn(i,a,b,g) for(LL i=a;i&lt;b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> remn(i,a,b,g) for(LL i=a;i&gt;b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;LL,LL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mkp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i128 __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(i128 &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    i128 f=<span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	x=-x;</span><br><span class="line">    	<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>)<span class="built_in">write</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>((x%<span class="number">10</span>)^<span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line">LL a,b,c,d,l=<span class="number">-1</span>,r=<span class="number">6001</span>,mid,ll,rr,mmiidd;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">che</span><span class="params">(LL mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,a,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,d,<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LL adneed=<span class="built_in">max</span>(a-j/<span class="number">4</span>-i,d-i/<span class="number">4</span>-j);</span><br><span class="line">			LL lef=mid-i-j;</span><br><span class="line">			<span class="keyword">if</span>(lef/<span class="number">2</span>&lt;adneed)<span class="keyword">continue</span>;</span><br><span class="line">			LL blef=<span class="built_in">max</span>(b-i/<span class="number">2</span>-j/<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line">			LL clef=<span class="built_in">max</span>(c-i/<span class="number">2</span>-j/<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line">			ll=<span class="number">-1</span>;</span><br><span class="line">			rr=lef+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>(ll+<span class="number">1</span>&lt;rr)</span><br><span class="line">			&#123;</span><br><span class="line">				mmiidd=ll+rr&gt;&gt;<span class="number">1</span>;</span><br><span class="line">				LL t=mmiidd+(lef-mmiidd)/<span class="number">4</span>;</span><br><span class="line">				<span class="keyword">if</span>(t&gt;=blef)rr=mmiidd;</span><br><span class="line">				<span class="keyword">else</span> ll=mmiidd;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(rr+(lef-rr)/<span class="number">4</span>&gt;=blef&amp;&amp;rr/<span class="number">4</span>+(lef-rr)&gt;=clef)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">	<span class="keyword">while</span>(l+<span class="number">1</span>&lt;r)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">che</span>(mid))r=mid;</span><br><span class="line">		<span class="keyword">else</span> l=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="t3">T3</h4>
<p><video src="https://cppomstar.github.io/images/CSP-SR1T3.mp4" controls><a href="https://cppomstar.github.io/images/CSP-SR1T3.mp4">Video</a></video></p>
<p>截至题解在 2024/9/4 22:40 UPD 唯一 AC，耶。</p>
<p>对了有一说一要是这是 OI 赛制我就只有 <span class="math inline">\(50 \
pts\)</span>。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/x3vu1l31.png"></p>
<p>倒反天罡了属于是。原因是最大值变量 <code>mc</code> 初值写挂。</p>
<p>UPD：赤石了，有原题，我还调那么久/fn。</p>
<p>神仙贪心。</p>
<p>一眼贪心想到 <code>A</code> 和一堆 <code>B</code>
交错排，实际上是对的，证明略。</p>
<p><del>实际实现见注释。（其实是我不会梳理这题的思路）</del></p>
<p>UPD：临危受命，嗓子废了，不会写也得写。</p>
<p>但还是不会写，于是完善注释。</p>
<p>说一下如何想到的吧，就是上面的基础思路，然后我想到：转换次数可以不同，而且枚举转换次数不会超时，里面就按题意来贪心。</p>
<p>于是这个方法就出来了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> esp 1e-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 999999999999999999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b,g) for(LL i=a;i&lt;=b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rem(i,a,b,g) for(LL i=a;i&gt;=b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> repn(i,a,b,g) for(LL i=a;i&lt;b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> remn(i,a,b,g) for(LL i=a;i&gt;b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;LL,LL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mkp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i128 __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(i128 &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;</span><br><span class="line">	i128 f=<span class="number">1</span>;</span><br><span class="line">	<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=-x;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">9</span>)<span class="built_in">write</span>(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>((x%<span class="number">10</span>)^<span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line">LL t,n,m,a,b,c,mc,sum,tt,ttt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;m&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		mc=(n<span class="number">-1</span>)/a+(m<span class="number">-1</span>)/b+<span class="number">2</span>;<span class="comment">//初值，即 AAAABBBB 排列</span></span><br><span class="line">    <span class="comment">//50 pts 因为写成 (n-1)/a+(m-1)/b+1，但是 RE 至今原因不明</span></span><br><span class="line">		tt=<span class="built_in">min</span>(n,m/c);<span class="comment">//可以 AB 转换的最多次数</span></span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,tt,<span class="number">1</span>)<span class="comment">//枚举次数</span></span><br><span class="line">		&#123;</span><br><span class="line">			sum=i*<span class="number">2</span>;<span class="comment">//i*2 个 A-&gt;B 或 B-&gt;A（包括了第一个和“第零个”）</span></span><br><span class="line">			<span class="keyword">if</span>(c&gt;b)<span class="comment">//i 个长度为 c 的 B 串的总贡献</span></span><br><span class="line">			&#123;</span><br><span class="line">				sum+=(((c<span class="number">-1</span>)/b)*i);</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">//处理剩下的 A</span></span><br><span class="line">			<span class="keyword">if</span>(n-i&gt;<span class="number">0</span>)<span class="comment">//A 够</span></span><br><span class="line">			&#123;</span><br><span class="line">				sum+=((n-i<span class="number">-1</span>)/a+<span class="number">1</span>);<span class="comment">//末尾放连续的 A</span></span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">//处理剩下的 B</span></span><br><span class="line">			<span class="keyword">if</span>(m-i*c&gt;=<span class="number">1</span>)<span class="comment">//B 的个数够</span></span><br><span class="line">      <span class="comment">//为什么是 &gt;=1 而不是 &gt;=0 ？因为 =0 的话相当于没有能“分配”的 B，不如不讨论，&gt;=1 的话可以扔一个在末尾（直接贡献加一，贪心地选择这样做）再讨论剩下的</span></span><br><span class="line">			&#123;</span><br><span class="line">				sum++;<span class="comment">//结尾的第一个 B 的贡献</span></span><br><span class="line">				LL lef=m-c*i<span class="number">-1</span>;<span class="comment">//剩的 B 的数量（lef=left（剩下的），但我怕关键字）</span></span><br><span class="line">        <span class="comment">//给前面的“凑整”</span></span><br><span class="line">				<span class="keyword">if</span>(c&lt;=b)<span class="comment">//有 b 个了就已经能转</span></span><br><span class="line">				&#123;</span><br><span class="line">					ttt=<span class="built_in">min</span>(i,lef/(b+<span class="number">1</span>-c));<span class="comment">//min(B 串个数,(剩下的)除以(c 个凑成 b+1 个还要的))</span></span><br><span class="line">          <span class="comment">//b+1 是因为要 b+1 个而不是 b 个才能加一个权值</span></span><br><span class="line">					sum+=ttt;<span class="comment">//加贡献</span></span><br><span class="line">					lef-=ttt*(b+<span class="number">1</span>-c);<span class="comment">//减数量</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span><span class="comment">//有 b 个还不能转</span></span><br><span class="line">				&#123;</span><br><span class="line">					ttt=<span class="built_in">min</span>(i,lef/(b+<span class="number">1</span>-c%b));</span><br><span class="line">          <span class="comment">//min(B 串个数,(剩下的)除以(需要补的“零头”))</span></span><br><span class="line">          <span class="comment">//![](https://cdn.luogu.com.cn/upload/image_hosting/wihugaum.png) 放张图辅助理解</span></span><br><span class="line">          <span class="comment">//因为贪心的想，能补全肯定补全</span></span><br><span class="line">					sum+=ttt;<span class="comment">//加贡献</span></span><br><span class="line">					lef-=ttt*(b+<span class="number">1</span>-c%b);<span class="comment">//减数量</span></span><br><span class="line">				&#125;</span><br><span class="line">				sum+=lef/b;<span class="comment">//剩下的全部在末尾</span></span><br><span class="line">			&#125;</span><br><span class="line">			mc=<span class="built_in">max</span>(mc,sum);</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;mc&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="csp-j-第一次模拟">CSP-J 第一次模拟</h3>
<h4 id="t4">T4</h4>
<p><video src="https://cppomstar.github.io/images/CSP-JR1T4.mp4" controls><a href="https://cppomstar.github.io/images/CSP-JR1T4.mp4">Video</a></video></p>
<p>邪门 <code>while</code> 加贪心。</p>
<p>感觉想起来比 T2、T3 更简单，也许是我的方法太过邪门了吧。</p>
<p>首先，一个石头一个石头跳和一次性越过多个石头没有任何区别，所以我觉得可以仅考虑每次跳一个石头。</p>
<p>想到 DP，<span class="math inline">\(dp_{i,j,0/1}\)</span>，然而有后效性，我就弃置了这个想法。</p>
<p>然后，想起初学时学的 <code>while</code>
循环，觉得好像可以拿这个做。</p>
<p><code>na</code> 记录青蛙 A 的位置，<code>nb</code>
同理。<code>tyq</code> 若为 <code>1</code> 则表示跳跃器在 A
手里，<code>2</code> 表示跳跃器在 B 手里。</p>
<p>讲解参见代码注释。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> esp 1e-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 999999999999999999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b,g) for(LL i=a;i&lt;=b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rem(i,a,b,g) for(LL i=a;i&gt;=b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> repn(i,a,b,g) for(LL i=a;i&lt;b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> remn(i,a,b,g) for(LL i=a;i&gt;b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;LL,LL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mkp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i128 __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(i128 &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    i128 f=<span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	x=-x;</span><br><span class="line">    	<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>)<span class="built_in">write</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>((x%<span class="number">10</span>)^<span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line">LL n,m,k,q,a[<span class="number">1010</span>],b[<span class="number">1010</span>],tyq=<span class="number">1</span>,na,nb,sum;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;q;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>)cin&gt;&gt;a[i];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>)cin&gt;&gt;b[i];</span><br><span class="line">	<span class="keyword">while</span>(na&lt;n||nb&lt;n)<span class="comment">//每一次代表一个“回合”</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(tyq==<span class="number">1</span>)<span class="comment">//跳跃器在 A 手里</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(na&lt;n&amp;&amp;<span class="built_in">labs</span>(a[na+<span class="number">1</span>]-b[nb])&lt;=q)<span class="comment">//若 A 能跳，且跳完能传递跳跃器，则 A 跳</span></span><br><span class="line">			&#123;</span><br><span class="line">				na++;</span><br><span class="line">				<span class="keyword">continue</span>;<span class="comment">//下一回合</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(nb&lt;n&amp;&amp;b[nb+<span class="number">1</span>]-b[nb]&lt;=m)<span class="comment">//若 B 能不带跳跃器跳，则 B 跳</span></span><br><span class="line">			&#123;</span><br><span class="line">				nb++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(nb&lt;n&amp;&amp;b[nb+<span class="number">1</span>]-b[nb]&gt;m&amp;&amp;<span class="built_in">labs</span>(a[na]-b[nb])&lt;=q)<span class="comment">//B 不能不带跳跃器跳且 A 能传递跳跃器，则传递，然后 B 跳</span></span><br><span class="line">			&#123;</span><br><span class="line">				sum++;<span class="comment">//次数加一</span></span><br><span class="line">				tyq=<span class="number">2</span>;<span class="comment">//跳跃器给 B</span></span><br><span class="line">				nb++;<span class="comment">//B 跳</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			na++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(nb&lt;n&amp;&amp;<span class="built_in">labs</span>(b[nb+<span class="number">1</span>]-a[na])&lt;=q)</span><br><span class="line">			&#123;</span><br><span class="line">				nb++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(na&lt;n&amp;&amp;a[na+<span class="number">1</span>]-a[na]&lt;=m)</span><br><span class="line">			&#123;</span><br><span class="line">				na++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(na&lt;n&amp;&amp;a[na+<span class="number">1</span>]-a[na]&gt;m&amp;&amp;<span class="built_in">labs</span>(b[nb]-a[na])&lt;=q)</span><br><span class="line">			&#123;</span><br><span class="line">				sum++;</span><br><span class="line">				tyq=<span class="number">1</span>;</span><br><span class="line">				na++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			nb++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>比赛</category>
        <category>CSP</category>
        <category>学校</category>
      </categories>
      <tags>
        <tag>比赛</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>排列 DP 学习笔记</title>
    <url>/2024/09/19/%E6%8E%92%E5%88%97-DP-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>咕咕咕。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>DP</category>
        <category>DP 优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>学习笔记</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>一种区间 DP</title>
    <url>/2024/06/20/%E4%B8%80%E7%A7%8D%E5%8C%BA%E9%97%B4-DP/</url>
    <content><![CDATA[<details class="note info no-icon"><summary><p>这里是题</p>
</summary>
<p><img src="https://cppomstar.github.io/images/qujiandpliti.png"></p>

</details>
<p>可以想到区间 DP。</p>
<details class="note info"><summary><p>原因</p>
</summary>
<p>如果不是从一个区间内往外 jumping，一定要走回头路，不优，所以是区间
DP。</p>

</details>
<p>然而，我们以前写的区间 DP
设计对这题并不适用，无法既高效又简单的转移。</p>
<p>然而，我们可以在以往的 <span class="math inline">\(dp[i][j]\)</span>
后再加一维，变成 <span class="math inline">\(dp[i][j][1/2]\)</span>。</p>
<p>其中，<span class="math inline">\(dp[i][j][1]\)</span> 表示把 <span class="math inline">\(i\sim j\)</span> 都 jumping 一遍后停在 <span class="math inline">\(i\)</span> 的最短路，而 <span class="math inline">\(dp[i][j][2]\)</span> 表示把 <span class="math inline">\(i\sim j\)</span> 都 jumping 一遍后停在 <span class="math inline">\(j\)</span> 的最短路。</p>
<p>具体转移很好想，是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[i][j][<span class="number">1</span>]=<span class="built_in">min</span>(dp[i+<span class="number">1</span>][j][<span class="number">1</span>]+<span class="built_in">dis</span>(i,i+<span class="number">1</span>),dp[i+<span class="number">1</span>][j][<span class="number">2</span>]+<span class="built_in">dis</span>(i,j));</span><br><span class="line">dp[i][j][<span class="number">2</span>]=<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>][<span class="number">1</span>]+<span class="built_in">dis</span>(i,j),dp[i][j<span class="number">-1</span>][<span class="number">2</span>]+<span class="built_in">dis</span>(j,j<span class="number">-1</span>));</span><br></pre></td></tr></table></figure>
<p><code>dis(i,j)</code> 代表 <span class="math inline">\(i\)</span>
荷叶直接 jumping 到 <span class="math inline">\(j\)</span>
荷叶的距离。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code(thanks to luogu 398152)
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> esp 1e-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 999999999999999999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b,g) for(LL i=a;i&lt;=b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rem(i,a,b,g) for(LL i=a;i&gt;=b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> repn(i,a,b,g) for(LL i=a;i&lt;b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> remn(i,a,b,g) for(LL i=a;i&gt;b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;LL,LL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mkp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i128 __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(i128 &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i128 f=<span class="number">1</span>;</span><br><span class="line">	x=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writing</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">10</span>)<span class="built_in">writing</span>(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">		x=-x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">writing</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">LL n;</span><br><span class="line"><span class="type">double</span> x[<span class="number">1010</span>],y[<span class="number">1010</span>],dp[<span class="number">1010</span>][<span class="number">1010</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis</span><span class="params">(LL i,LL j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(len,<span class="number">1</span>,n,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n-len+<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LL j=i+len<span class="number">-1</span>;</span><br><span class="line">			dp[i][j][<span class="number">1</span>]=<span class="built_in">min</span>(dp[i+<span class="number">1</span>][j][<span class="number">1</span>]+<span class="built_in">dis</span>(i,i+<span class="number">1</span>),dp[i+<span class="number">1</span>][j][<span class="number">2</span>]+<span class="built_in">dis</span>(i,j));</span><br><span class="line">			dp[i][j][<span class="number">2</span>]=<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>][<span class="number">1</span>]+<span class="built_in">dis</span>(i,j),dp[i][j<span class="number">-1</span>][<span class="number">2</span>]+<span class="built_in">dis</span>(j,j<span class="number">-1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>,dp[<span class="number">1</span>][n][<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>DP</category>
        <category>区间 DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>区间 DP</tag>
      </tags>
  </entry>
  <entry>
    <title>dp 练手题 题解</title>
    <url>/2024/06/06/dp-%E7%BB%83%E6%89%8B%E9%A2%98-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<details class="note primary"><summary><p>题面</p>
</summary>
<p>题面：</p>
<p>在盖了一所正方形房子后，FJ
最近又得到了一块正三角形的土地，他也想在这块土地上建造一所房子，这次这个房子也必须是正三角形的。但是，这块土地并非十全十美，上面有很多不平坦的地方（也可以叫瑕疵）。这些瑕疵十分恶心，以至于根本不能在上面盖一砖一瓦。他希望找到一块最大的正三角形无瑕疵土地来盖房子。不过，这并不是什么难题，FJ
在 <span class="math inline">\(1\)</span>
秒内就轻松解决了这个问题。现在，您也来试试吧。</p>
<p><img src="https://cppomstar.github.io/images/202466timian.png"></p>
<p>如图所示，黑色的小正三角形表示瑕疵。</p>
<p>输入：</p>
<p>第一行，一个整数 <span class="math inline">\(n\)</span>，表示土地纵向划分为 <span class="math inline">\(n\)</span> 行。</p>
<p>（<span class="math inline">\(n\le 1000\)</span>）</p>
<p>接下来的 <span class="math inline">\(n\)</span> 行，第 <span class="math inline">\(i\)</span> 行包括了 <span class="math inline">\((n−i)\times 2+1\)</span> 个有效字符。</p>
<p><code>-</code> 表示这块土地是好的，<code>#</code>
表示这块土地有瑕疵。</p>
<p>为了保持三角形的形状，输入文件中会出现空格。</p>
<p>输出：</p>
<p>一行一个整数，表示最大的正三角形包括的小三角形数。</p>
<p>样例输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">#-##----#</span><br><span class="line"> -----#-</span><br><span class="line">  ---#-</span><br><span class="line">   -#-</span><br><span class="line">    -</span><br></pre></td></tr></table></figure>
<p>样例输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>

</details>
<p>我相信很多人和我一样看这题会想用二维前缀和做。</p>
<p>我试过了，比较麻烦。</p>
<p>下面介绍一种 DP 的方法。</p>
<h4 id="思路">思路</h4>
<p>有两种三角形，正的（尖朝下），或者反的（尖朝上）。</p>
<p>我们设计状态：</p>
<p><code>a[i][j]</code>，以第 <span class="math inline">\(i\)</span>
行，第 <span class="math inline">\(j\)</span>
列为底三角形的最大可用三角形边长（<span class="math inline">\(j\bmod
2=1\)</span>）；</p>
<p><code>b[i][j]</code>，以第 <span class="math inline">\(i\)</span>
行，第 <span class="math inline">\(j\)</span>
列为顶三角形的最大可用三角形边长（<span class="math inline">\(j\bmod
2=0\)</span>）。</p>
<h5 id="正的">正的</h5>
<p><img src="https://cppomstar.github.io/images/202466z.png"></p>
<p>我们看 <span class="math inline">\(x\)</span> 这个小三角形。</p>
<p>如果它是瑕疵，直接 <code>a[i][j]=0</code>。</p>
<p>否则，可以从 <span class="math inline">\(y,z\)</span>
转移过来，那么显然转移式子是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a[i][j]=<span class="built_in">min</span>(a[i<span class="number">-1</span>][j],a[i<span class="number">-1</span>][j+<span class="number">2</span>])*(mp[i<span class="number">-1</span>][j+<span class="number">1</span>]==<span class="string">&#x27;-&#x27;</span>)+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><code>mp</code> 是存整个地图的数组。</p>
<p>另，我们的存储方式是：把所有三角形看成一个个点，然后往左压，具体见代码。</p>
<h5 id="反的">反的</h5>
<p>同理。</p>
<p>如果它是瑕疵，直接 <code>b[i][j]=0</code>。</p>
<p>否则，可以从下方转移过来，那么显然转移式子是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">b[i][j]=<span class="built_in">min</span>(b[i+<span class="number">1</span>][j<span class="number">-2</span>],b[i+<span class="number">1</span>][j])*(mp[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="string">&#x27;-&#x27;</span>)+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>所以行要从后<strong>向前</strong>遍历。</p>
<h4 id="坑点">坑点</h4>
<p>输入直接 <code>cin</code>。</p>
<p>要取所有状态的 <code>max</code>。</p>
<p>最后时求的是面积不是边长。</p>
<h4 id="时间复杂度">时间复杂度</h4>
<p><span class="math inline">\(O(n^2)\)</span>，能过。</p>
<p>甚至 <span class="math inline">\(n\)</span> 可以到一万。</p>
<h4 id="代码">代码</h4>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> esp 1e-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 999999999999999999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b,g) for(LL i=a;i&lt;=b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rem(i,a,b,g) for(LL i=a;i&gt;=b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> repn(i,a,b,g) for(LL i=a;i&lt;b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> remn(i,a,b,g) for(LL i=a;i&gt;b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;LL,LL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mkp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i128 __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(i128 &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i128 f=<span class="number">1</span>;</span><br><span class="line">	x=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writing</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">10</span>)<span class="built_in">writing</span>(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">		x=-x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">writing</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">LL n;</span><br><span class="line">LL a[<span class="number">1010</span>][<span class="number">1010</span>],b[<span class="number">1010</span>][<span class="number">1010</span>],mca,mcb;</span><br><span class="line"><span class="type">char</span> x,mp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,<span class="number">2</span>*n<span class="number">-2</span>*i+<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;x;</span><br><span class="line">			mp[i][j]=x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,<span class="number">2</span>*n<span class="number">-2</span>*i+<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(mp[i][j]==<span class="string">&#x27;#&#x27;</span>)a[i][j]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				a[i][j]=<span class="built_in">min</span>(a[i<span class="number">-1</span>][j],a[i<span class="number">-1</span>][j+<span class="number">2</span>])*(mp[i<span class="number">-1</span>][j+<span class="number">1</span>]==<span class="string">&#x27;-&#x27;</span>)+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			mca=<span class="built_in">max</span>(mca,a[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rem</span>(i,n,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">2</span>,<span class="number">2</span>*n<span class="number">-2</span>*i,<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(mp[i][j]==<span class="string">&#x27;#&#x27;</span>)b[i][j]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				b[i][j]=<span class="built_in">min</span>(b[i+<span class="number">1</span>][j<span class="number">-2</span>],b[i+<span class="number">1</span>][j])*(mp[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="string">&#x27;-&#x27;</span>)+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			mcb=<span class="built_in">max</span>(mcb,b[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">max</span>(mca,mcb)*<span class="built_in">max</span>(mca,mcb)&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h4 id="致谢">致谢</h4>
<p>教练 zxc，提供题目；</p>
<p>同学 whl，提供思路；</p>
<p>同学 zxz，提出可能的时间复杂度（虽然没做出来）。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>日常</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC 356 题解</title>
    <url>/2024/06/02/ABC-356-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="c">C</h3>
<h4 id="题目大意">题目大意</h4>
<p>有 <span class="math inline">\(N\)</span> 个编号分别为 <span class="math inline">\(1, 2, \dots, N\)</span> 的钥匙。</p>
<p>其中一些是真钥匙，其他的都是假钥匙。</p>
<p>有一扇门，你可以插入任意数量的钥匙。</p>
<p>只有插入至少 <span class="math inline">\(K\)</span>
把真钥匙，门才会打开。</p>
<p>已经对这些钥匙进行了 <span class="math inline">\(M\)</span>
次测试。</p>
<p>其中，第 <span class="math inline">\(i\)</span> 次测试过程如下：</p>
<ul>
<li>将 <span class="math inline">\(C_i\)</span> 把钥匙，分别是 <span class="math inline">\(A_{i,1}, A_{i,2}, \dots, A_{i,C_i}\)</span>
插入门。</li>
<li>测试结果用一个英文字母 <span class="math inline">\(R_i\)</span>
表示。
<ul>
<li><span class="math inline">\(R_i=\)</span> <code>o</code> 表示在第
<span class="math inline">\(i\)</span> 次测试中门打开了。</li>
<li><span class="math inline">\(R_i=\)</span> <code>x</code> 表示在第
<span class="math inline">\(i\)</span> 次测试中门没有打开。</li>
</ul></li>
</ul>
<p>有 <span class="math inline">\(2^N\)</span>
种可能的钥匙组合，在这些组合中，你需要找出与任何测试结果都不矛盾的组合数。</p>
<p>给定的测试结果有可能是错误的，没有任何组合满足条件。在这种情况下，输出
<span class="math inline">\(0\)</span>。</p>
<h4 id="思路">思路</h4>
<p>就是暴力，但赛时时间复杂度分析错误（我以为是 <span class="math inline">\(2^n\times n\times m\times k\)</span>，实际应是
<span class="math inline">\(2^n\times n\times
m\)</span>），导致没做出来。</p>
<p>实际极限情况运算次数约为 <span class="math inline">\(2^{15}\times
15\times 100=49152000\approx 5\times 10^7\)</span>，可以通过。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> esp 1e-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 999999999999999999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b,g) for(LL i=a;i&lt;=b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rem(i,a,b,g) for(LL i=a;i&gt;=b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> repn(i,a,b,g) for(LL i=a;i&lt;b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> remn(i,a,b,g) for(LL i=a;i&gt;b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;LL,LL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mkp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i128 __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(i128 &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i128 f=<span class="number">1</span>;</span><br><span class="line">	x=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writing</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">10</span>)<span class="built_in">writing</span>(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">		x=-x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">writing</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">LL n,m,k,c[<span class="number">110</span>],a[<span class="number">110</span>][<span class="number">20</span>],s;</span><br><span class="line">LL f[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> r[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==n+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,m,<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LL sum=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">rep</span>(j,<span class="number">1</span>,c[i],<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				sum+=f[a[i][j]];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!((sum&gt;=k&amp;&amp;r[i]==<span class="string">&#x27;o&#x27;</span>)||(sum&lt;k&amp;&amp;r[i]==<span class="string">&#x27;x&#x27;</span>)))<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		s++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(x+<span class="number">1</span>);</span><br><span class="line">	f[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(x+<span class="number">1</span>);</span><br><span class="line">	f[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;c[i];</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,c[i],<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		cin&gt;&gt;r[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h3 id="d">D</h3>
<h4 id="题目大意-1">题目大意</h4>
<p>给定整数 <span class="math inline">\(N\)</span> 和 <span class="math inline">\(M\)</span> ，计算 <span class="math inline">\(\displaystyle \sum_{k=0}^{N}\)</span> <span class="math inline">\(\rm{popcount}\)</span> <span class="math inline">\((k \mathbin{\&amp;} M)\)</span> 模 <span class="math inline">\(998244353\)</span> 的结果。</p>
<h4 id="思路-1">思路</h4>
<p>赛时没有一点思路，反映出我位运算练的少。</p>
<p>建议大家阅读<a href="https://atcoder.jp/contests/abc356/editorial/10144">官方题解</a>，比较清晰，而且可以提升英语阅读能力。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> esp 1e-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 999999999999999999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b,g) for(LL i=a;i&lt;=b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rem(i,a,b,g) for(LL i=a;i&gt;=b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> repn(i,a,b,g) for(LL i=a;i&lt;b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> remn(i,a,b,g) for(LL i=a;i&gt;b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;LL,LL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mkp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i128 __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(i128 &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i128 f=<span class="number">1</span>;</span><br><span class="line">	x=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writing</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">10</span>)<span class="built_in">writing</span>(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">		x=-x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">writing</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">LL n,m,sum;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(LL j,LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sum+=((n&gt;&gt;(j+<span class="number">1</span>))&lt;&lt;j);</span><br><span class="line">	sum%=MOD;</span><br><span class="line">	<span class="keyword">if</span>(n&amp;(<span class="number">1LL</span>&lt;&lt;j))</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=((n&amp;((<span class="number">1LL</span>&lt;&lt;j)<span class="number">-1</span>))+<span class="number">1</span>);</span><br><span class="line">		sum%=MOD;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="built_in">repn</span>(i,<span class="number">0</span>,<span class="number">60</span>,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(m&amp;(<span class="number">1LL</span>&lt;&lt;i))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">f</span>(i,n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h3 id="e">E</h3>
<h4 id="题目大意-2">题目大意</h4>
<p>给你一个长度为 <span class="math inline">\(N\)</span> 的序列 <span class="math inline">\(A=(A_1,\ldots,A_N)\)</span> 。</p>
<p>求 <span class="math inline">\(\displaystyle
\sum_{i=1}^{N-1}\sum_{j=i+1}^{N}\left\lfloor\frac{\max(A_i,A_j)}{\min(A_i,A_j)}\right\rfloor\)</span>
.</p>
<p>这里， <span class="math inline">\(\lfloor x \rfloor\)</span>
表示不大于 <span class="math inline">\(x\)</span> 的最大整数。例如，
<span class="math inline">\(\lfloor 3.14 \rfloor=3\)</span> 和 <span class="math inline">\(\lfloor 2 \rfloor=2\)</span> 。</p>
<h4 id="思路-2">思路</h4>
<p>好像和官方想一块去了，但觉得自己写的不够好，于是参考了官方题解。</p>
<p>设 <span class="math inline">\(A\)</span> 中最大的元素是 <span class="math inline">\(M\)</span> .</p>
<p>我们要对所有满足 <span class="math inline">\(i&lt;j\)</span> 的 <span class="math inline">\((i,j)\)</span>
进行求和，又因为可以看出我们改变顺序并不会影响答案，于是乎我们可以重新排列序列
<span class="math inline">\(A\)</span>。</p>
<p>那么，我们把 <span class="math inline">\(A\)</span> 按升序排序。</p>
<p>此时，如果 <span class="math inline">\(i&lt;j\)</span> ，就有 <span class="math inline">\(A_i \leq A_j\)</span> ，所以 <span class="math inline">\(\displaystyle
\left\lfloor\frac{\max(A_i,A_j)}{\min(A_i,A_j)}\right\rfloor =
\left\lfloor\frac{A_j}{A_i}\right\rfloor\)</span> 。</p>
<p>于是，原式可以变形为： <span class="math display">\[
\displaystyle \sum_{i=1}^{N-1}\sum_{j=i+1}^{N}\displaystyle
\left\lfloor\frac{A_j}{A_i}\right\rfloor =
\sum_{i=1}^{N-1}\sum_{n}n*g(A_i,n)
\]</span></p>
<p>其中 <span class="math inline">\(g(d,n)\)</span> 是满足 <span class="math inline">\(\displaystyle
\left\lfloor\frac{A_j}{d}\right\rfloor=n\)</span> 的 <span class="math inline">\(j\)</span> 的个数。</p>
<p>设 <span class="math inline">\(C_x\)</span> 是满足 <span class="math inline">\(A_i=x\)</span> 的 <span class="math inline">\(i\)</span> 的个数（此处原文可能笔误，题解上写的是
with，我觉得应该是 wich）。</p>
<p>通过预处理 <span class="math inline">\(C\)</span> 的前缀和，可以
<span class="math inline">\(O(1)\)</span> 算出 <span class="math inline">\(f(d,n)\)</span>，具体见代码。</p>
<p>时间复杂度不证了，是 <span class="math inline">\(O(m\log
n)\)</span>，可以通过。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> esp 1e-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 999999999999999999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b,g) for(LL i=a;i&lt;=b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rem(i,a,b,g) for(LL i=a;i&gt;=b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> repn(i,a,b,g) for(LL i=a;i&lt;b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> remn(i,a,b,g) for(LL i=a;i&gt;b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;LL,LL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mkp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i128 __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(i128 &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i128 f=<span class="number">1</span>;</span><br><span class="line">	x=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writing</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">10</span>)<span class="built_in">writing</span>(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">		x=-x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">writing</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">LL n,sum,f[<span class="number">1000010</span>],x;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">		f[x]++;<span class="comment">//下标计数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">1000001</span>,<span class="number">1</span>)f[i]+=f[i<span class="number">-1</span>];<span class="comment">//前缀和</span></span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">1000000</span>,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LL vitamin_D=f[i]-f[i<span class="number">-1</span>];<span class="comment">//重复的数量</span></span><br><span class="line">		<span class="built_in">rep</span>(k,<span class="number">1</span>,<span class="number">1000000</span>/i,<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			sum+=k*(f[<span class="built_in">min</span>(<span class="number">1000001LL</span>,(k+<span class="number">1</span>)*i<span class="number">-1</span>)]-f[k*i<span class="number">-1</span>])*vitamin_D;<span class="comment">//算式，移项可得</span></span><br><span class="line">		&#125;</span><br><span class="line">		sum-=vitamin_D*(vitamin_D+<span class="number">1</span>)/<span class="number">2</span>;<span class="comment">//去掉相同的数的两两之间的</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h3 id="总结致谢">总结&amp;致谢</h3>
<p>还是练得少，手比较生。</p>
<p>另外反映出我的两个问题：</p>
<ol type="1">
<li>位运算掌握不牢</li>
<li>分析时间复杂度方面掌握不牢</li>
</ol>
<p>感谢 AtCoder 官方，提供了好题以及题解供我参考。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>比赛</category>
        <category>ABC</category>
      </categories>
      <tags>
        <tag>比赛</tag>
        <tag>题解</tag>
        <tag>ABC</tag>
      </tags>
  </entry>
  <entry>
    <title>单调队列 &amp; 斜率优化 DP 学习笔记</title>
    <url>/2024/05/11/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96-%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96DP/</url>
    <content><![CDATA[<p>UpDate on 2024/5/23 代码增加一点注释</p>
<p>UpDate on 2024/5/28 增加一个同学写的反思</p>
<p>UpDate on 2024/5/29 写完单调队列优化多重背包部分</p>
<p>UpDate on 2024/5/31 单调队列优化多重背包部分添加代码</p>
<h4 id="单调队列优化-dp">单调队列优化 DP</h4>
<h5 id="单调队列">单调队列</h5>
<p>注意，其与优先队列不是同一种数据结构。（其实也不是严格的队列）</p>
<p><a href="https://www.luogu.com.cn/problem/P1886">其模板题</a>。</p>
<p>每当一个新的数加入，当队尾大于等于/小于等于（取决于每一道题目）这个数时，弹出队尾（因此这不是严格的队列）并继续比较直到队尾不满足其大于等于/小于等于这个数或队列空。然后将这个数加入队尾。</p>
<p>还有一个操作：当队头不优时，弹出队头。</p>
<h5 id="似乎无法优化-dp">似乎无法优化 DP？</h5>
<p><a href="https://www.luogu.com.cn/problem/CF372C">例题</a></p>
<p>状态设计可以想到是当放第 <span class="math inline">\(i\)</span>
个烟花的时候你在 <span class="math inline">\(j\)</span>
位置能获得的最大开心度。</p>
<p>转移方程依据题意，是 <span class="math display">\[
f_{i,j}=\max\lbrace f_{i-1,k}+b_i-|a_i-j|\rbrace
\]</span> <details class="note info no-icon"><summary><p>此处 <span class="math inline">\(k\)</span> 范围</p>
</summary>
<p><span class="math display">\[
j-(t_i-t_{i-1})\times d\le k \le j+(t_i-t_{i-1})\times d
\]</span></p>

</details></p>
<p>然而会超时，考虑优化。</p>
<p>但是，这坨式子很明显无法单调队列优化，其他优化似乎也不行。</p>
<h5 id="一个想法">一个想法</h5>
<p>暴力是三层循环，第一层 <span class="math inline">\(i\)</span>，第二层
<span class="math inline">\(j\)</span>，第三层 <span class="math inline">\(k\)</span>（因为 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 决定 <span class="math inline">\(k\)</span> 的范围）。</p>
<p>转移在 <span class="math inline">\(k\)</span> 层进行。</p>
<p>此时 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 已经固定，所以： <span class="math display">\[
f_{i,j}=\max\lbrace f_{i-1,k}\rbrace+b_i-|a_i-j|
\]</span> 既然 <span class="math inline">\(+b_i-|a_i-j|\)</span>
影响单调队列，我们就提出去！</p>
<p>于是时间复杂度降到 <span class="math inline">\(O(nm)\)</span>。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code from OI-wiki
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">150000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxm = <span class="number">300</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll f[<span class="number">2</span>][maxn];</span><br><span class="line">ll a[maxm], b[maxm], t[maxm];</span><br><span class="line"><span class="type">int</span> n, m, d;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> que[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fl = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">207</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">  <span class="built_in">memset</span>(que, <span class="number">0</span>, <span class="built_in">sizeof</span>(que));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">  fl = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;  <span class="comment">// 在这里使用了单调队列的优化，推式子详见上面</span></span><br><span class="line">      <span class="keyword">for</span> (; k &lt;= <span class="built_in">min</span>(<span class="number">1ll</span> * n, j + d * (t[i] - t[i - <span class="number">1</span>])); k++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; f[fl ^ <span class="number">1</span>][que[r]] &lt;= f[fl ^ <span class="number">1</span>][k]) r--;</span><br><span class="line">        que[++r] = k;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (l &lt;= r &amp;&amp; que[l] &lt; <span class="built_in">max</span>(<span class="number">1ll</span>, j - d * (t[i] - t[i - <span class="number">1</span>]))) l++;</span><br><span class="line">      f[fl][j] = f[fl ^ <span class="number">1</span>][que[l]] - <span class="built_in">abs</span>(a[i] - j) + b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fl ^= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; t[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// then dp</span></span><br><span class="line">  <span class="built_in">dp</span>();</span><br><span class="line">  ll ans = <span class="number">-1e18</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = <span class="built_in">max</span>(ans, f[fl ^ <span class="number">1</span>][i]);</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h5 id="多重背包的单调队列优化">多重背包的单调队列优化</h5>
<p>写一些我的见解吧。</p>
<p>这应该是多重背包的最优解了。</p>
<p><a href="https://www.luogu.com.cn/problem/P1776">例题</a>。</p>
<p>我们知道，暴力的转移方程是：</p>
<p><span class="math display">\[
dp_j=max\{dp_{j-kc_i}+kw_i\}
\]</span></p>
<p>其中 <span class="math inline">\(1\le k \le
min\{m_i,\frac{j}{c_i}\}\)</span>。</p>
<div class="note primary"><p>特别提一下，我这里的各个变量和数组与原题不同，物品个数是 <span class="math inline">\(n\)</span>，体积是 <span class="math inline">\(c_i\)</span>，价值是 <span class="math inline">\(w_i\)</span>，有 <span class="math inline">\(m_i\)</span> 个，背包大小是 <span class="math inline">\(C\)</span>。</p>
</div>
<p>打暴力的代码的话，是三层循环，我们发现 <span class="math inline">\(i,j\)</span> 之间没有关系，但是 <span class="math inline">\(j,k\)</span> 有关系，<span class="math inline">\(k\)</span> 在 <span class="math inline">\(j\)</span> 上有滑动窗口。</p>
<p>看似无法应用单调队列。</p>
<p>但是，我们发现：<span class="math inline">\(j+m\times
c_i=j+(m+p)\times c_i-p\times c_i\)</span>。</p>
<p>所以我们可以想到，当某些 <span class="math inline">\(j\)</span>
除以某个 <span class="math inline">\(c_i\)</span> 的余数相同时，他们的
<span class="math inline">\(k\)</span> 会有重叠。</p>
<p>那么，我们设 <span class="math inline">\(j=yc_i+b\)</span>，其中
<span class="math inline">\(b\)</span> 为余数（<span class="math inline">\(j\bmod c_i\)</span>），<span class="math inline">\(y=\lfloor\frac{j}{c_i}\rfloor\)</span>。</p>
<p>带入，原方程变为：</p>
<p><span class="math display">\[
dp_{yc_i+b}=max\{dp_{b+(y-k)c_i}+kw_i\}
\]</span></p>
<p>我们发现它看上去还是不能优化。</p>
<p>然而我们可以令 <span class="math inline">\(x=y-k\)</span>，此时方程变为：</p>
<p><span class="math display">\[
dp_{yc_i+b}=max\{dp_{b+xc_i}-xw_i+yw_i\}
\]</span></p>
<p>然后就能单调队列优化了。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code by whl(I improved its code style and added some annotations)
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL N=<span class="number">4e4</span>+<span class="number">10</span>;</span><br><span class="line">LL n,m,v,w,c,q[N],hh,tt,f[N],g[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(n--)<span class="comment">//输入时直接处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;v,&amp;w,&amp;c);</span><br><span class="line">        <span class="built_in">memcpy</span>(g,f,<span class="built_in">sizeof</span>(f));<span class="comment">//滚动数组的一种实现方式，上文的方程等都用了滚动数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;w;i++)<span class="comment">//余数，所以是 [0,w)</span></span><br><span class="line">        &#123;</span><br><span class="line">            hh=<span class="number">0</span>;</span><br><span class="line">            tt=<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//单调队列，这样等价于 h=1,t=0</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=m;j+=w)<span class="comment">//将这个余数的所有状态更新</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(hh&lt;=tt&amp;&amp;q[hh]&lt;j-w*c)hh++;<span class="comment">//个数超了 c</span></span><br><span class="line">                <span class="keyword">while</span>(hh&lt;=tt&amp;&amp;g[q[tt]]-v*q[tt]/w&lt;=g[j]-v*j/w)tt--;<span class="comment">//队尾没有 j 优</span></span><br><span class="line">                q[++tt]=j;</span><br><span class="line">                f[j]=g[q[hh]]+v*((j-q[hh])/w);<span class="comment">//转移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,f[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h4 id="斜率优化参考了罗勇军郭卫斌的算法竞赛">斜率优化！（参考了罗勇军、郭卫斌的《算法竞赛》）</h4>
<p>有一种 DP 转移方程： <span class="math display">\[
dp_i=\min\{dp_j-a_id_j\}(0\le j&lt;i,d_j\le d_{j+1},a_i\le a_{i+1})
\]</span> 朴素的去 DP，<span class="math inline">\(O(n^2)\)</span>。</p>
<h5 id="转换">转换</h5>
<p>把 <span class="math inline">\(i\)</span> 看作不变的常量。</p>
<p>把除了 <span class="math inline">\(dp_i\)</span> 以外的所有与 <span class="math inline">\(i\)</span> 有关的项看作常量。</p>
<p>把 <span class="math inline">\(j\)</span> 看作变量。</p>
<p>要求 <span class="math inline">\(j\)</span> 变化时 <span class="math inline">\(dp_i\)</span> 的最优值。</p>
<p>把 <span class="math inline">\(\min\)</span> 去掉，就变成了： <span class="math display">\[
dp_j=a_id_j+dp_i
\]</span> 为了让它看着像一次函数（才能求斜率），设 <span class="math inline">\(y=dp_j,x=d_j,k=a_i,b=dp_i\)</span>。</p>
<p>原式变为 <span class="math inline">\(y=kx+b\)</span>。</p>
<p>斜率优化需要满足几个条件：</p>
<ol type="1">
<li><p><span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 与 <span class="math inline">\(j\)</span> 有关，且只有 <span class="math inline">\(y\)</span> 中包含 <span class="math inline">\(dp_j\)</span>。于是 <span class="math inline">\((x,y)\)</span> 这个点就是一种决策。</p></li>
<li><p>斜率 <span class="math inline">\(k\)</span>、截距 <span class="math inline">\(b\)</span> 与 <span class="math inline">\(i\)</span> 有关，并且只有 <span class="math inline">\(b\)</span> 中含 <span class="math inline">\(dp_i\)</span>，其中最小的 <span class="math inline">\(b\)</span> 包含最小的 <span class="math inline">\(dp_i\)</span>，也就是转移方程的解。</p></li>
</ol>
<p><span class="math inline">\((x_1,y_1)\)</span> 和 <span class="math inline">\((x_2,y_2)\)</span> 这两个点组成的直线的斜率为
<span class="math inline">\((y_2-y_1)/(x_2-x_1)\)</span>，我们会发现这个斜率<strong>只与
<span class="math inline">\(j\)</span>
有关</strong>，于是可以用单调队列！</p>
<div class="note warning"><p>还有一点，<span class="math inline">\(x\)</span> 与 <span class="math inline">\(k\)</span> 要单调增加。</p>
<p>具体来说：<span class="math inline">\(x\)</span> 随 <span class="math inline">\(j\)</span> 递增而递增，<span class="math inline">\(k\)</span> 随 <span class="math inline">\(i\)</span> 递增而递增。</p>
</div>
<h5 id="求某个-dp_i">求某个 <span class="math inline">\(dp_i\)</span></h5>
<p>我们要求最优点，设它为 <span class="math inline">\(v\)</span>。</p>
<p>利用“下凸壳”。</p>
<p>如果这次转移的各个点（决策）是这样的：</p>
<p><img src="https://cppomstar.github.io/images/xielvDPno1.png"></p>
<p>上凸壳就是 <span class="math inline">\(2,3,4\)</span>。</p>
<p>我们可以发现：经过上凸壳<strong>中间那个点</strong>（即 <span class="math inline">\(3\)</span>）的直线的截距（<span class="math inline">\(b\)</span>）一定大于（《算法竞赛》中此处为“小于”，应为笔误）<span class="math inline">\(2\)</span> 和 <span class="math inline">\(4\)</span> 的直线的截距，于是 <span class="math inline">\(3\)</span>
一定不是最终的最优的点，去掉（绿色代表删掉了）：</p>
<p><img src="https://cppomstar.github.io/images/xielvDPno2.png"></p>
<p>剩的点都满足下凸壳关系（<span class="math inline">\(12\)</span>
的斜率小于 <span class="math inline">\(24\)</span> 的斜率）。</p>
<p>假设在这里面 <span class="math inline">\(12\)</span> 的斜率小于 <span class="math inline">\(k\)</span>，<span class="math inline">\(34\)</span> 的斜率大于 <span class="math inline">\(k\)</span>，那么最优点就是 <span class="math inline">\(2\)</span>（如下图，蓝色直线即为斜率为 <span class="math inline">\(k\)</span> 的直线）。</p>
<p><img src="https://cppomstar.github.io/images/xielvDPno3.png"></p>
<p>我们发现这部分用单调队列做非常容易。</p>
<h6 id="入队">入队</h6>
<p>我们现在要处理一个斜率：<span class="math inline">\((y_2-y_1)/(x_2-x_1)\)</span>。</p>
<p>斜率要<strong>单调上升</strong>，因为是下凸壳。</p>
<p>如果准备进队了发现斜率不单调上升，就把前面弹走。</p>
<p>每次进队后就大致像下图的结构（By OI Painter）：</p>
<p><img src="https://cppomstar.github.io/images/xielvDPno4.png"></p>
<h6 id="出队">出队</h6>
<p>注意，这说的是前面提到的“当队头不优时，弹出队头”。</p>
<p>设队头的两个点分别是 <span class="math inline">\(v_1\)</span> 和
<span class="math inline">\(v_2\)</span>。</p>
<p>如果 <span class="math inline">\(v_1v_2\)</span>
这条线段的斜率小于<strong>等于</strong>（我认为此处应该有等于，因为我们的条件是“左边的斜率小于
<span class="math inline">\(k\)</span>，右边的的斜率大于 <span class="math inline">\(k\)</span>”） <span class="math inline">\(k\)</span>，就可以把 <span class="math inline">\(v_1\)</span> 弹出去了（如上，不可能最优）。</p>
<p>然后一直弹，弹到 <span class="math inline">\(v_1v_2\)</span>
这条线段的斜率大于 <span class="math inline">\(k\)</span>，此时队头就是这个 <span class="math inline">\(dp_i\)</span> 的最优点。</p>
<h5 id="快速地求所有的-dp_i">（快速地）求所有的 <span class="math inline">\(dp_i\)</span></h5>
<p>然而我们会发现一个显著的问题：</p>
<details class="note danger"><summary><p>问题</p>
</summary>
<p>求一个 <span class="math inline">\(dp_i\)</span> 是 <span class="math inline">\(O(n)\)</span> 的。</p>
<p>求所有的是 <span class="math inline">\(O(n^2)\)</span> 的。</p>
<p>那这和暴力似乎没有区别。</p>

</details>
<p>我们来列一下各个 <span class="math inline">\(dp_i\)</span>
要处理的决策点：</p>
<p>举个例子，有两个数，<span class="math inline">\(j\)</span> 和 <span class="math inline">\(o\)</span>。</p>
<p>不妨设 <span class="math inline">\(j&lt;o\)</span>。</p>
<p><span class="math inline">\(dp_j\)</span>
要处理的之前的决策点是：</p>
<p><span class="math display">\[
{v_0,v_1,\dots,s_j}
\]</span></p>
<p><span class="math inline">\(dp_o\)</span>
要处理的之前的决策点是：</p>
<p><span class="math display">\[
{v_0,v_1,\dots,s_j,\dots,s_o}
\]</span></p>
<p>前面的 <span class="math inline">\({v_0,v_1,\dots,s_j}\)</span>
是重复的，可以避免这些重复的扫描。</p>
<details class="note info"><summary><p>方法</p>
</summary>
<p>《算法竞赛》上我觉得讲麻烦了，我讲一下我的想法：</p>
<p>我们前文保证过“<span class="math inline">\(x\)</span> 与 <span class="math inline">\(k\)</span> 单调增加”，于是 <span class="math inline">\(k_o\)</span> 的斜率一定大于 <span class="math inline">\(k_j\)</span> 的。</p>
<p>于是我们只用一个单调队列从头到尾处理即可，每次处理完剩下的数据后一个位置还能用。</p>
<p>时间复杂度骤降至 <span class="math inline">\(O(n)\)</span>。</p>

</details>
<p>核心代码如下：</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        main code
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(h&lt;t&amp;&amp;slope<span class="comment">/*斜率函数，但这个词一般表示“斜坡”*/</span>(q[h],q[h+<span class="number">1</span>])&lt;k)h++;</span><br><span class="line">    dp[i]=<span class="comment">/*状态转移方程*/</span>;</span><br><span class="line">    <span class="keyword">while</span>(h&lt;t&amp;&amp;<span class="built_in">slope</span>(i,q[t<span class="number">-1</span>])&lt;<span class="built_in">slope</span>(q[t<span class="number">-1</span>],q[t]))t--;</span><br><span class="line">    q[++t]=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p>然而我想说点有关代码的事：</p>
<details class="note success"><summary><p>既然写到了代码</p>
</summary>
<p>首先要有一个良好的代码习惯，比如记住上面那个代码，当作模板；</p>
<p>第二是我个人倡导的把大括号写开，即：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="comment">/*...*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*do sth*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而不是用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="comment">/*...*/</span>)&#123;</span><br><span class="line">    <span class="comment">/*do sth*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者其他难以找到这个大括号对应的前面的或后面的在哪、难以调试的代码风格。</p>
<p>这样可以更好地调试，也可以有更好的心态（这是作为 OIer
很重要的一点）。</p>
<p>第三就是如果遇到毒瘤出题人卡精度，使用 <code>slope</code>
会有精度误差时，可以像我的同学 ly 那样写一个 <code>slope_fz</code> 和
<code>slope_fm</code> 函数，比较时就交叉相乘。</p>

</details>
<h5 id="例题"><a href="https://www.acwing.com/problem/content/description/4841/">例题</a></h5>
<p>设 <span class="math inline">\(f_i\)</span> 表示输出前 <span class="math inline">\(i\)</span> 个单词的最少费用，那么根据题意，我们设
<span class="math inline">\(s_i\)</span> 表示前 <span class="math inline">\(i\)</span> 个单词的费用之和。</p>
<p>转移方程就是：</p>
<p><span class="math display">\[
dp_i=\min\{dp_j+(s_i-s_j)^2+M\}
\]</span></p>
<p>其中 <span class="math inline">\(1\le j&lt;i\)</span>。</p>
<p>中间过程大致如下：</p>
<p>展开、移项（对照 <span class="math inline">\(y=kx+b\)</span>
的格式和要求），得：</p>
<p><span class="math display">\[
dp_j+{s_j}^2=2s_is_j+dp_i-{s_i}^2-M
\]</span></p>
<p>那么，<span class="math inline">\(y\)</span> 是 <span class="math inline">\(dp_j+{s_j}^2\)</span>，<span class="math inline">\(x\)</span> 是 <span class="math inline">\(2s_j\)</span>，<span class="math inline">\(k\)</span> 是 <span class="math inline">\(s_i\)</span>，<span class="math inline">\(b\)</span> 是 <span class="math inline">\(dp_i-{s_i}^2-M\)</span>，而且符合条件。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code by ly（I solved the bugs）
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll n,m,q[N],l,r;</span><br><span class="line">ll a[N],dp[N];</span><br><span class="line"><span class="function">ll <span class="title">get_x</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>*a[x];<span class="comment">//即 2*s[j]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">get_y</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dp[x]+a[x]*a[x];<span class="comment">//即 dp[j]+s[j]*s[j]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">slope_fz</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">get_y</span>(x)-<span class="built_in">get_y</span>(y);<span class="comment">//斜率的分子</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">slope_fm</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">get_x</span>(x)-<span class="built_in">get_x</span>(y);<span class="comment">//斜率的分母</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">	&#123;</span><br><span class="line">		l=<span class="number">0</span>;</span><br><span class="line">		r=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">		<span class="built_in">memset</span>(q,<span class="number">0</span>,<span class="built_in">sizeof</span>(q));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">			a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;r&amp;&amp;<span class="built_in">slope_fz</span>(q[l+<span class="number">1</span>],q[l])&lt;=(__int128)a[i]*<span class="built_in">slope_fm</span>(q[l+<span class="number">1</span>],q[l])) l++;</span><br><span class="line">			dp[i]=dp[q[l]]+m+(a[i]-a[q[l]])*(a[i]-a[q[l]]);<span class="comment">//注意，转移时还是按原转移方程进行转移</span></span><br><span class="line">			<span class="keyword">while</span>(l&lt;r&amp;&amp;(__int128)<span class="built_in">slope_fz</span>(i,q[r])*<span class="built_in">slope_fm</span>(q[r],q[r<span class="number">-1</span>])&lt;=(__int128)<span class="built_in">slope_fz</span>(q[r],q[r<span class="number">-1</span>])*<span class="built_in">slope_fm</span>(i,q[r])) r--;</span><br><span class="line">			q[++r]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp[n]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

    </div>
</div>
<div class="note success"><p>斜率优化的代码特别容易踩坑。</p>
<p>具体我目前知道的有：</p>
<ol type="1">
<li>数据卡精度</li>
</ol>
<div id="两种解决方案" class="tabs">
<ul class="nav-tabs">
<li class="tab">
<a href="#两种解决方案-1">方法一</a>
</li>
<li class="tab">
<a href="#两种解决方案-2">方法二</a>
</li>
</ul>
<div class="tab-content">
<div id="两种解决方案-1" class="tab-pane">
<p>
开 <code>long double</code> 或者写高精度，不推荐。
</p>
<p>
但一般不卡精度时直接除就可以了。
</p>
</div>
<div id="两种解决方案-2" class="tab-pane">
<p>
像上文的代码那样写一个分子函数一个分母函数，比较时交叉相乘，<strong>但一定要注意不等号反向的问题！</strong>
</p>
<p>
同时还能解决分母可能为 $ 0 $ 的问题。
</p>
</div>
</div>
</div>
<ol start="2" type="1">
<li>单调队列写挂（即我解决的 bug）（解决方案：写成上文代码那样的初始
<code>l=r=0</code> 用时 <code>l&lt;r</code>
单调队列，或者这么写，见下：）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*初始化*/</span></span><br><span class="line">l=<span class="number">1</span>;</span><br><span class="line">r=<span class="number">0</span>;</span><br><span class="line">q[++l]=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*用的时候*/</span></span><br><span class="line">l&lt;=r</span><br></pre></td></tr></table></figure>
<p>原因见<a href="https://www.luogu.com/article/lf5fferx">此</a>。</p>
</div>
<h4 id="小结">小结</h4>
<p>斜率优化可以算是比较高级的 DP 优化了。</p>
<p>有些别的优化时间复杂度比斜率优化劣，比如笔者 2024.5.19
写的一道题，四边形不等式 <span class="math inline">\(O(n\log
n)\)</span>，而斜率优化 <span class="math inline">\(O(n)\)</span>。</p>
<p>也可以找些习题进行练习，如 <a href="https://www.luogu.com.cn/problem/P5785" class="uri">https://www.luogu.com.cn/problem/P5785</a> 等。</p>
<p>另，由于本博客成文时间仓促，可能会有些错误，欢迎指出。</p>
<h4 id="致谢">致谢</h4>
<p>我学校的信息学教练 zxc，为此文提供了基础；</p>
<p>OI-wiki 斜率优化、单调队列优化部分编写人员及 OI-wiki
建设者，为本文提供代码及部分参考；</p>
<p>同学 whl，专门给我讲了一次斜率优化，并在 2024/5/31
提供单调队列优化多重背包例题代码；</p>
<p>同学
ly，提供例题代码（虽然我改了一点）、经典错误和其解决方案和反思；</p>
<p>OI Painter 开发者 EternalAlexander，提供一张图片的绘画支持；</p>
<p>tldraw 开发者，提供三张图片的绘画支持；</p>
<p>AcWing 站长 yxc，提供例题；</p>
<p>罗勇军、郭卫斌及其他《算法竞赛》编写、贡献者，为斜率优化部分提供参考。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>DP</category>
        <category>DP 优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>学习笔记</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>决策单调性 DP</title>
    <url>/2024/05/30/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7%20DP/</url>
    <content><![CDATA[<p>请注意，本篇博客<strong>不会讲解决策单调性 DP
及四边形不等式的基本原理等</strong>，主要是为了解决目前网上学习笔记多且清晰（如<a href="https://www.luogu.com/article/95ahsmez">whl
的学习笔记</a>）但例题讲解相对较晦涩的问题。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>DP</category>
        <category>DP 优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>学习笔记</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树学习笔记</title>
    <url>/2024/04/25/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>请注意，本文默认大家学过单改区查的基础线段树（包括动态开点），若未学，请移步
<a href="https://oi-wiki.org/ds/seg/">OI-wiki</a>，例题可以使用树状数组的题目。</p>
<h3 id="区间修改懒标记lazy-tag">区间修改：懒标记（lazy-tag）</h3>
<details class="note info no-icon"><summary><p><a href="https://www.luogu.com.cn/problem/P3372">【模板】线段树
1</a></p>
</summary>
<p>题目描述</p>
<p>已知一个数列，你需要进行下面两种操作：</p>
<ol type="1">
<li>将某区间每一个数加上 <span class="math inline">\(k\)</span>。</li>
<li>求出某区间每一个数的和。</li>
</ol>
<p>输入格式</p>
<p>第一行包含两个整数 <span class="math inline">\(n,
m\)</span>，分别表示该数列数字的个数和操作的总个数。</p>
<p>第二行包含 <span class="math inline">\(n\)</span>
个用空格分隔的整数，其中第 <span class="math inline">\(i\)</span>
个数字表示数列第 <span class="math inline">\(i\)</span> 项的初始值。</p>
<p>接下来 <span class="math inline">\(m\)</span> 行每行包含 <span class="math inline">\(3\)</span> 或 <span class="math inline">\(4\)</span> 个整数，表示一个操作，具体如下：</p>
<ol type="1">
<li><code>1 x y k</code>：将区间 <span class="math inline">\([x,
y]\)</span> 内每个数加上 <span class="math inline">\(k\)</span>。</li>
<li><code>2 x y</code>：输出区间 <span class="math inline">\([x,
y]\)</span> 内每个数的和。</li>
</ol>
<p>输出格式</p>
<p>输出包含若干行整数，即为所有操作 2 的结果。</p>
<p>样例输入 #1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 5 4 2 3</span><br><span class="line">2 2 4</span><br><span class="line">1 2 3 2</span><br><span class="line">2 3 4</span><br><span class="line">1 1 5 1</span><br><span class="line">2 1 4</span><br></pre></td></tr></table></figure>
<p>样例输出 #1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br><span class="line">8</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<p>提示</p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据：<span class="math inline">\(1 \le n, m \le {10}^5\)</span>。</p>

</details>
<p>很明显，如果用暴力进行区间修改，不能通过。</p>
<p>那么引入 lazy-tag。</p>
<p>首先，先介绍 lazy-tag 的概念：</p>
<p>对于每个有 lazy-tag
的节点，在只有需要用到自己的子节点时才会把修改的命令（lazy-tag）交给子节点。</p>
<p>lazy-tag 用一个叫做 <code>push_down</code> 的操作下放修改操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">p_d_</span><span class="params">(<span class="type">long</span> <span class="type">long</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> L=u&lt;&lt;<span class="number">1</span>,R=u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">	t[L].sum+=t[u].y*(t[L].r-t[L].l+<span class="number">1</span>);<span class="comment">//处理左子树总和</span></span><br><span class="line">	t[R].sum+=t[u].y*(t[R].r-t[R].l+<span class="number">1</span>);<span class="comment">//右子树</span></span><br><span class="line">	t[L].y+=t[u].y;<span class="comment">//标记下放</span></span><br><span class="line">	t[R].y+=t[u].y;<span class="comment">//同上</span></span><br><span class="line">	t[u].y=<span class="number">0</span>;<span class="comment">//清零，代表下放结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>y</code> 就是 lazy-tag。</p>
<p>第二，<code>up_date</code> 函数在符合
<code>t[u].l&gt;=l&amp;&amp;t[u].r&lt;=r</code> 时，将 lazy-tag
加上此次加操作的值，并增加此区间总和。</p>
<p>若不符合，则进行 <code>push_down</code>
操作，为递归左右子树铺垫。</p>
<p>第三，<code>query</code> 函数在
<code>t[u].l&gt;=l&amp;&amp;t[u].r&lt;=r</code> 不成立时，也需进行
<code>push_down</code> 操作，原因同上。</p>
<p>显然，此时复杂度为 <span class="math inline">\(O(mlogn)\)</span></p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,m,x,y;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> k;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[<span class="number">500010</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> l,r,sum,y;</span><br><span class="line">&#125;t[<span class="number">500010</span>&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p_u_</span><span class="params">(<span class="type">long</span> <span class="type">long</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].sum=t[u&lt;&lt;<span class="number">1</span>].sum+t[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p_d_</span><span class="params">(<span class="type">long</span> <span class="type">long</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> L=u&lt;&lt;<span class="number">1</span>,R=u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">	t[L].sum+=t[u].y*(t[L].r-t[L].l+<span class="number">1</span>);</span><br><span class="line">	t[R].sum+=t[u].y*(t[R].r-t[R].l+<span class="number">1</span>);</span><br><span class="line">	t[L].y+=t[u].y;</span><br><span class="line">	t[R].y+=t[u].y;</span><br><span class="line">	t[u].y=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">b_</span><span class="params">(<span class="type">long</span> <span class="type">long</span> u,<span class="type">long</span> <span class="type">long</span> l,<span class="type">long</span> <span class="type">long</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].l=l,t[u].r=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].sum=a[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">b_</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">	<span class="built_in">b_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">p_u_</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">u_d_</span><span class="params">(<span class="type">long</span> <span class="type">long</span> u,<span class="type">long</span> <span class="type">long</span> l,<span class="type">long</span> <span class="type">long</span> r,<span class="type">long</span> <span class="type">long</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[u].l&gt;=l&amp;&amp;t[u].r&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].sum+=c*(t[u].r-t[u].l+<span class="number">1</span>);</span><br><span class="line">		t[u].y+=c;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">p_d_</span>(u);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> mid=(t[u].l+t[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)<span class="built_in">u_d_</span>(u&lt;&lt;<span class="number">1</span>,x,y,c);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) <span class="built_in">u_d_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y,c);</span><br><span class="line">	<span class="built_in">p_u_</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">q_</span><span class="params">(<span class="type">long</span> <span class="type">long</span> u,<span class="type">long</span> <span class="type">long</span> l,<span class="type">long</span> <span class="type">long</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=t[u].l&amp;&amp;r&gt;=t[u].r)<span class="keyword">return</span> t[u].sum;</span><br><span class="line">	<span class="built_in">p_d_</span>(u);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> mid=(t[u].l+t[u].r)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)ans+=<span class="built_in">q_</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)ans+=<span class="built_in">q_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">b_</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;k;</span><br><span class="line">		<span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">			<span class="built_in">u_d_</span>(<span class="number">1</span>,x,y,k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">			cout&lt;&lt;<span class="built_in">q_</span>(<span class="number">1</span>,x,y)&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h3 id="权值线段树">权值线段树</h3>
<p>普通的线段树，记录的是数组中当前区间的各种信息。</p>
<p>权值线段树，则记录的是每种数据出现的次数。</p>
<p>如：数组为 <code>1 1 4 5 1 4</code></p>
<p>则其出现次数为（从 <span class="math inline">\(0\)</span>
开始）<code>0 3 0 0 2 1</code>。</p>
<h3 id="线段树合并">线段树合并</h3>
<p>前置知识：权值线段树（一般线段树合并合并的是权值线段树）。</p>
<blockquote>
<p>线段树合并是指建立一棵新的线段树，这棵线段树的每个节点都是两棵原线段树对应节点合并后的结果。它常常被用于维护树上或是图上的信息。——OI
wiki</p>
</blockquote>
<p>如果每次合并都新开一棵满树，时间、空间都无法接受。</p>
<p>那么，就需要本文开头提到的前置知识动态开点。</p>
<p>设需要合并的两棵树分别叫 <span class="math inline">\(T1\)</span> 和
<span class="math inline">\(T2\)</span>。</p>
<p>从上往下（即从 <span class="math inline">\(1\)</span>
号节点开始递归向下），对于每个节点，若 <span class="math inline">\(T1\)</span> 上无此节点，就只加入 <span class="math inline">\(T2\)</span> 上的此节点。反之亦然。</p>
<p>如果都有此节点，若是叶子节点，直接合并所有信息。</p>
<p>若否，通过子节点的返回（返回左儿子、右儿子）更新。</p>
<p>OI-wiki
上对其时间复杂度的证明不严谨，读者可以在写的时候自己证其时间复杂度。</p>
<h3 id="扫描线">扫描线</h3>
<p>下面这张动图，诠释了这种算法在处理面积并上的的大致思路：（感谢
OI-wiki，面积并处理部分也请参见 OI-wiki）</p>
<p><img src="https://cppomstar.github.io//images/scanning.svg"></p>
<p>本博客则讲述其解决周长并上的解法，详见<a href="https://cppomstar.github.io/2024/04/25/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#t7">T7</a>。</p>
<h3 id="例题">例题</h3>
<h4 id="t1">T1</h4>
<p><img src="https://cppomstar.github.io//images/segtreeT1.png"></p>
<p>首先的思路是暴力（二维前缀和），然而会时间和空间超限。</p>
<p>优化：因为“星星按y坐标增序给出，y坐标相同的按x坐标增序给出”，所以只需查找从
<span class="math inline">\(0\)</span>
高度到此高度范围内共有多少颗星星（因为保证 <span class="math inline">\(y\)</span> 增序了），求和即可。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> esp 1e-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 999999999999999999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b,g) for(LL i=a;i&lt;=b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rem(i,a,b,g) for(LL i=a;i&gt;=b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> repn(i,a,b,g) for(LL i=a;i&lt;b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> remn(i,a,b,g) for(LL i=a;i&gt;b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;LL,LL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mkp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i128 __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(i128 &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i128 f=<span class="number">1</span>;</span><br><span class="line">	x=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writing</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">10</span>)<span class="built_in">writing</span>(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">		x=-x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">writing</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">LL n,x[<span class="number">1000010</span>],y[<span class="number">1000010</span>];</span><br><span class="line">LL k;</span><br><span class="line">LL a[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">	LL l,r,sum,y;</span><br><span class="line">&#125;t[<span class="number">1000010</span>&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p_u_</span><span class="params">(LL u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].sum=t[u&lt;&lt;<span class="number">1</span>].sum+t[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p_d_</span><span class="params">(LL u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL L=u&lt;&lt;<span class="number">1</span>,R=u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">	t[L].sum+=t[u].y*(t[L].r-t[L].l+<span class="number">1</span>);</span><br><span class="line">	t[R].sum+=t[u].y*(t[R].r-t[R].l+<span class="number">1</span>);</span><br><span class="line">	t[L].y+=t[u].y;</span><br><span class="line">	t[R].y+=t[u].y;</span><br><span class="line">	t[u].y=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">b_</span><span class="params">(LL u,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].l=l;</span><br><span class="line">	t[u].r=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LL mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">b_</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">	<span class="built_in">b_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">p_u_</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">u_d_</span><span class="params">(LL u,LL l,LL r,LL c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[u].l&gt;=l&amp;&amp;t[u].r&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].sum+=c*(t[u].r-t[u].l+<span class="number">1</span>);</span><br><span class="line">		t[u].y+=c;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">p_d_</span>(u);</span><br><span class="line">	LL mid=(t[u].l+t[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)<span class="built_in">u_d_</span>(u&lt;&lt;<span class="number">1</span>,l,r,c);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) <span class="built_in">u_d_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,c);</span><br><span class="line">	<span class="built_in">p_u_</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">q_</span><span class="params">(LL u,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=t[u].l&amp;&amp;r&gt;=t[u].r)<span class="keyword">return</span> t[u].sum;</span><br><span class="line">	<span class="built_in">p_d_</span>(u);</span><br><span class="line">	LL mid=(t[u].l+t[u].r)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)ans+=<span class="built_in">q_</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)ans+=<span class="built_in">q_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">LL sum[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">b_</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">320000</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LL u=x[i]+<span class="number">1</span>;</span><br><span class="line">		LL v=<span class="built_in">q_</span>(<span class="number">1</span>,<span class="number">1</span>,u);</span><br><span class="line">		<span class="built_in">u_d_</span>(<span class="number">1</span>,u,u,<span class="number">1</span>);</span><br><span class="line">		sum[v+<span class="number">1</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;sum[i]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h4 id="t2"><a href="https://www.luogu.com.cn/problem/P5057">T2</a></h4>
<p>很明显，因为是“区查单改”且是较为特殊的异或，我们需要把“异或次数”作为
lazy-tag。</p>
<p>同时因为只有 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(0\)</span>，所以 lazy-tag 每次异或（即 <span class="math inline">\(+1\bmod 2\)</span>）即可。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> esp 1e-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 999999999999999999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b,g) for(LL i=a;i&lt;=b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rem(i,a,b,g) for(LL i=a;i&gt;=b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> repn(i,a,b,g) for(LL i=a;i&lt;b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> remn(i,a,b,g) for(LL i=a;i&gt;b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;LL,LL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mkp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i128 LL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(i128 &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i128 f=<span class="number">1</span>;</span><br><span class="line">	x=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writing</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">10</span>)<span class="built_in">writing</span>(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">		x=-x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">writing</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">LL n,m,x,y,k,a[<span class="number">100010</span>],tt[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">	LL l,r,sum,y;</span><br><span class="line">&#125;t[<span class="number">100010</span>&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p_u_</span><span class="params">(LL u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].sum=t[u&lt;&lt;<span class="number">1</span>].sum+t[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p_d_</span><span class="params">(LL u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL L=u&lt;&lt;<span class="number">1</span>,R=u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">	t[L].sum=t[L].r-t[L].l+<span class="number">1</span>-t[L].sum;</span><br><span class="line">	t[R].sum=t[R].r-t[R].l+<span class="number">1</span>-t[R].sum;</span><br><span class="line">	t[L].y^=<span class="number">1</span>;</span><br><span class="line">	t[R].y^=<span class="number">1</span>;</span><br><span class="line">	t[u].y=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">b_</span><span class="params">(LL u,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].l=l,t[u].r=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].sum=tt[l<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LL mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">b_</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">	<span class="built_in">b_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">p_u_</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">u_d_</span><span class="params">(LL u,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[u].l&gt;=l&amp;&amp;t[u].r&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].sum=t[u].r-t[u].l+<span class="number">1</span>-t[u].sum;</span><br><span class="line">		t[u].y^=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t[u].y)<span class="built_in">p_d_</span>(u);</span><br><span class="line">	LL mid=(t[u].l+t[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)<span class="built_in">u_d_</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)<span class="built_in">u_d_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="built_in">p_u_</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">q_</span><span class="params">(LL u,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=t[u].l&amp;&amp;r&gt;=t[u].r)<span class="keyword">return</span> t[u].sum;</span><br><span class="line">	<span class="keyword">if</span>(t[u].y)<span class="built_in">p_d_</span>(u);</span><br><span class="line">	LL mid=(t[u].l+t[u].r)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)ans+=<span class="built_in">q_</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)ans+=<span class="built_in">q_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="built_in">b_</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(k);</span><br><span class="line">		<span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">read</span>(x);</span><br><span class="line">			<span class="built_in">read</span>(y);</span><br><span class="line">			<span class="built_in">u_d_</span>(<span class="number">1</span>,x,y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">read</span>(x);</span><br><span class="line">			y=x;</span><br><span class="line">			<span class="built_in">write</span>(<span class="built_in">q_</span>(<span class="number">1</span>,x,y));</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h4 id="t3"><a href="https://www.luogu.com.cn/problem/P4145">T3</a></h4>
<p>当然，“开方”操作的懒标记以及修改都很难做。</p>
<p>然而，我们发现：<span class="math inline">\(\Bigg \lfloor
\sqrt{\sqrt{\sqrt{\sqrt{\sqrt{\sqrt 10^{12}}}}}} \Bigg
\rfloor=1\)</span></p>
<p>所以就这样操作即可：不是全 <span class="math inline">\(0\)</span>
或全 <span class="math inline">\(1\)</span>，暴力；是，不管。</p>
<h4 id="t4"><a href="https://www.luogu.com.cn/problem/P3373">T4</a></h4>
<p>我们需要两个 lazy-tag，一个是乘的，一个是加的。</p>
<p>优先级是乘 <span class="math inline">\(&gt;\)</span>
加，因为加完再乘，加的那部分也要被乘，反之不然。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,p,opt,x,y,k;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">xds</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> l,r,sum,m,a;</span><br><span class="line">&#125;t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pu</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].sum=(t[u&lt;&lt;<span class="number">1</span>].sum+t[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> l=u&lt;&lt;<span class="number">1</span>,r=l|<span class="number">1</span>;</span><br><span class="line">	t[l].sum=(<span class="number">1ll</span>*t[l].sum*t[u].m+<span class="number">1ll</span>*(t[l].r-t[l].l+<span class="number">1</span>)*t[u].a)%p;</span><br><span class="line">	t[r].sum=(<span class="number">1ll</span>*t[r].sum*t[u].m+<span class="number">1ll</span>*(t[r].r-t[r].l+<span class="number">1</span>)*t[u].a)%p;</span><br><span class="line">	t[l].m=<span class="number">1ll</span>*t[l].m*t[u].m%p;</span><br><span class="line">	t[r].m=<span class="number">1ll</span>*t[r].m*t[u].m%p;</span><br><span class="line">	t[l].a=(<span class="number">1ll</span>*t[l].a*t[u].m+t[u].a)%p;</span><br><span class="line">	t[r].a=(<span class="number">1ll</span>*t[r].a*t[u].m+t[u].a)%p;</span><br><span class="line">	t[u].m=<span class="number">1</span>;</span><br><span class="line">	t[u].a=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">b</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].l=l;</span><br><span class="line">	t[u].r=r;</span><br><span class="line">	t[u].m=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].sum=a[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> z=t[u].l+t[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">b</span>(u&lt;&lt;<span class="number">1</span>,l,z);</span><br><span class="line">	<span class="built_in">b</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,z+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">pu</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mu</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[u].l&gt;=l&amp;&amp;t[u].r&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].sum=<span class="number">1ll</span>*t[u].sum*k%p;</span><br><span class="line">		t[u].m=<span class="number">1ll</span>*t[u].m*k%p;</span><br><span class="line">		t[u].a=<span class="number">1ll</span>*t[u].a*k%p;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t[u].m!=<span class="number">1</span>||t[u].a)<span class="built_in">pd</span>(u);</span><br><span class="line">	<span class="type">int</span> z=t[u].l+t[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=z)<span class="built_in">mu</span>(u&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;z)<span class="built_in">mu</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">	<span class="built_in">pu</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">au</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[u].l&gt;=l&amp;&amp;t[u].r&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].sum=(t[u].sum+<span class="number">1ll</span>*k*(t[u].r-t[u].l+<span class="number">1</span>))%p;</span><br><span class="line">		t[u].a=(t[u].a+k)%p;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t[u].m!=<span class="number">1</span>||t[u].a)<span class="built_in">pd</span>(u);</span><br><span class="line">	<span class="type">int</span> z=t[u].l+t[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=z)<span class="built_in">au</span>(u&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;z)<span class="built_in">au</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">	<span class="built_in">pu</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">q</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[u].l&gt;=l&amp;&amp;t[u].r&lt;=r)<span class="keyword">return</span> t[u].sum;</span><br><span class="line">	<span class="keyword">if</span>(t[u].m!=<span class="number">1</span>||t[u].a)<span class="built_in">pd</span>(u);</span><br><span class="line">	<span class="type">int</span> z=t[u].l+t[u].r&gt;&gt;<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=z)sum=(sum+<span class="built_in">q</span>(u&lt;&lt;<span class="number">1</span>,l,r))%p;</span><br><span class="line">	<span class="keyword">if</span>(r&gt;z) sum=(sum+<span class="built_in">q</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r))%p;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">b</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;opt;</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">			<span class="built_in">mu</span>(<span class="number">1</span>,x,y,k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">			<span class="built_in">au</span>(<span class="number">1</span>,x,y,k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">			cout&lt;&lt;<span class="built_in">q</span>(<span class="number">1</span>,x,y)&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h4 id="t5">T5</h4>
<details class="note info no-icon"><summary><p>工厂</p>
</summary>
<p>小明的叔叔是一家工厂的厂长。叔叔的工厂有 n 个车间，编号为 1～n。</p>
<p>管理工厂是很麻烦的事情，特别是在多次调整机器以及员工之后，统计总生产量更是难事。</p>
<p>第 i 个车间在刚开始的时候机器生产力为 ai，有 bi
个员工，那么这个车间的生产力就为ai*bi。</p>
<p>工厂的总生产力定义为所有车间的生产力之和。</p>
<p>接下来的 m 天，每天叔叔就会调整一段区间的车间。</p>
<p>有两种调整：</p>
<p>第一种，是对于一段区间[l,r]的每一个车间重新分配每个车间的工人数为
x。</p>
<p>第二种，是对于一段区间[l,r]的每一个车间增加机器生产力 x。</p>
<p>现在，小明的叔叔想知道每天调整之后工厂的生产量变为多少。</p>

</details>
<p>我们发现，这和 T4 很像，只是“加”变为了“覆盖”。</p>
<p>于是把“加” lazy-tag 变为“覆盖”的即可。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code(thanks to lqs)
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 400010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> esp 1e-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 999999999999999999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b,g) for(LL i=a;i&lt;=b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rem(i,a,b,g) for(LL i=a;i&gt;=b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> repn(i,a,b,g) for(LL i=a;i&lt;b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> remn(i,a,b,g) for(LL i=a;i&gt;b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;LL,LL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mkp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i128 __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (ls+1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lm (l+r&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rm (lm+1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(i128 &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i128 f=<span class="number">1</span>;</span><br><span class="line">	x=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writing</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">10</span>)<span class="built_in">writing</span>(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">		x=-x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">writing</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">LL n,q,s,t,d,a[N],b[N],ans[N],sa[N],sb[N],ta[N],tb[N];</span><br><span class="line">string op;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pu</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ans[x]=ans[ls]+ans[rs];</span><br><span class="line">	sa[x]=sa[ls]+sa[rs];</span><br><span class="line">	sb[x]=sb[ls]+sb[rs];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pd</span><span class="params">(LL x,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sa[ls]+=ta[x]*(lm-l+<span class="number">1</span>);</span><br><span class="line">	sa[rs]+=ta[x]*(r-rm+<span class="number">1</span>);</span><br><span class="line">	ta[ls]+=ta[x];</span><br><span class="line">	ta[rs]+=ta[x];</span><br><span class="line">	<span class="keyword">if</span>(tb[x])</span><br><span class="line">	&#123;</span><br><span class="line">		sb[ls]=tb[x]*(lm-l+<span class="number">1</span>);</span><br><span class="line">		sb[rs]=tb[x]*(r-rm+<span class="number">1</span>);</span><br><span class="line">		ans[ls]=tb[x]*sa[ls];</span><br><span class="line">		ans[rs]=tb[x]*sa[rs];</span><br><span class="line">		tb[ls]=tb[rs]=tb[x];</span><br><span class="line">		tb[x]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ans[ls]+=ta[x]*sb[ls];</span><br><span class="line">		ans[rs]+=ta[x]*sb[rs];</span><br><span class="line">	&#125;</span><br><span class="line">	ta[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bu</span><span class="params">(LL x,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">        ans[x]=a[l]*b[l];</span><br><span class="line">        sa[x]=a[l];</span><br><span class="line">		sb[x]=b[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bu</span>(ls,l,lm);</span><br><span class="line">	<span class="built_in">bu</span>(rs,rm,r);</span><br><span class="line">    <span class="built_in">pu</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">se</span><span class="params">(LL x,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t&lt;l||s&gt;r)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(s&lt;=l&amp;&amp;r&lt;=t)</span><br><span class="line">	&#123;</span><br><span class="line">		sb[x]=d*(r-l+<span class="number">1</span>);</span><br><span class="line">		ans[x]=d*sa[x];</span><br><span class="line">		tb[x]=d;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pd</span>(x,l,r);</span><br><span class="line">	<span class="built_in">se</span>(ls,l,lm);</span><br><span class="line">	<span class="built_in">se</span>(rs,rm,r);</span><br><span class="line">	<span class="built_in">pu</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(LL x,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t&lt;l||s&gt;r)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(s&lt;=l&amp;&amp;r&lt;=t)</span><br><span class="line">	&#123;</span><br><span class="line">		sa[x]+=d*(r-l+<span class="number">1</span>);</span><br><span class="line">		ans[x]+=d*sb[x];</span><br><span class="line">		ta[x]+=d;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pd</span>(x,l,r);</span><br><span class="line">	<span class="built_in">add</span>(ls,l,lm);</span><br><span class="line">	<span class="built_in">add</span>(rs,rm,r);</span><br><span class="line">	<span class="built_in">pu</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>)cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">	<span class="built_in">bu</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(q--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;op&gt;&gt;s&gt;&gt;t&gt;&gt;d;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="string">&quot;Set&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">se</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;ans[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h4 id="t6"><a href="https://www.luogu.com.cn/problem/CF600E">T6</a></h4>
<p>权值线段树 <span class="math inline">\(+\)</span> 线段树合并。</p>
<p>每个子树中的颜色，开一颗权值线段树，向上回溯时合并即可。</p>
<h4 id="t7"><a href="https://www.luogu.com.cn/problem/P1856">T7</a></h4>
<p>首先，需要离散化，而后处理时有两种思路：</p>
<div class="tabs" id="两种思路"><ul class="nav-tabs"><li class="tab"><a href="#两种思路-1">思路一</a></li><li class="tab"><a href="#两种思路-2">思路二</a></li></ul><div class="tab-content"><div class="tab-pane" id="两种思路-1"><p>用一棵线段树，所以有一点点思维难度。</p>
<p>从上向下扫描，每次遇到一条边，若为上边，则在线段树上此区间进行加操作，下边则在此区间进行减操作。与面积并时相似。这是横边。竖边则利用扫描线走过的距离乘横向距离即可。</p>
<p>可以参考<a href="https://www.luogu.com.cn/article/9cuyuf44">这篇题解</a>。</p></div><div class="tab-pane" id="两种思路-2"><p>思路一的思维难度在于，竖边的处理较为麻烦，那么我们就如法炮制，竖边也建一棵线段树处理。</p></div></div></div>
<h3 id="小结">小结</h3>
<p>其实线段树还有不少应用，限于篇幅只能列出一部分。</p>
<p>赛中一般不会出裸线段树，所以想到用线段树是一个重要环节。</p>
<p>剩余部分可以参见
OI-wiki，讲的很清晰。有时间或有需求也可以学习几种线段树变形（李超等）。</p>
<p>另，由于部分题目代码过于长或因为某题最好自己写代码以学习，所以我没有放。</p>
<h3 id="致谢">致谢</h3>
<p>我学校的信息学教练 zxc 以及不是我学校的一位教练
gtc，为此文提供了例题以及基础；</p>
<p>OI-wiki 线段树部分编写人员及 OI-wiki
建设者，为本文线段树合并部分提供了定义以及为扫描线提供动图讲解；</p>
<p>我之前的英语老师 Cally，为本博客风格提供建议；</p>
<p>同学 lqs、whl，为我改代码（T5，lqs），讲解 T4（whl）；</p>
<p>hexo、github以及 next，为本博客提供支持；</p>
<p>同学 lyh，帮我调弄 hexo；</p>
<p>洛谷，提供题目、上传图片、教会我 <span class="math inline">\(\LaTeX\)</span>；</p>
<p><span class="math inline">\(mathjax\)</span>，对本文提供 <span class="math inline">\(\LaTeX\)</span> 支持。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>next 自带 tab 的 bug 修复</title>
    <url>/2024/05/30/next-%E8%87%AA%E5%B8%A6-tab-%E7%9A%84-bug-%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<p><a href="https://theme-next.js.org/docs/tag-plugins/tabs">我们知道，next
自带了一个东西叫 tabs</a>。</p>
<p>然而它有点 bug。</p>
<p>如果你用 mathjax 渲染，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% tabs 两种解决方案, -1 %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 方法一 --&gt;</span><br><span class="line"></span><br><span class="line">开 `long double` 或者写高精度，不推荐。</span><br><span class="line"></span><br><span class="line">但一般不卡精度时直接除就可以了。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 方法二 --&gt;</span><br><span class="line"></span><br><span class="line">像上文的代码那样写一个分子函数一个分母函数，比较时交叉相乘，**但一定要注意不等号反向的问题！**</span><br><span class="line"></span><br><span class="line">同时还能解决分母可能为 $0$ 的问题。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>
<p>渲染完毕，点开“方法二”，我们发现那个 <code>$0$</code>
没渲染出来。（不知道咋的在这里没了，但在其他地方不加下方的更改还有，大家可以自己试试）</p>
<p>翻了翻源码，发现似乎这里的源码不太一样：</p>
<p>正常的：<code>&lt;span class="math inline"&gt;\(0\)&lt;/span&gt;</code></p>
<p>这里的：<code>&lt;span class="math inline"&gt;(0)&lt;/span&gt;</code></p>
<p>于是我想到在那个 <code>$0$</code> 左右加空格，变成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% tabs 两种解决方案修复版, -1 %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 方法一修复版 --&gt;</span><br><span class="line"></span><br><span class="line">开 `long double` 或者写高精度，不推荐。</span><br><span class="line"></span><br><span class="line">但一般不卡精度时直接除就可以了。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 方法二修复版 --&gt;</span><br><span class="line"></span><br><span class="line">像上文的代码那样写一个分子函数一个分母函数，比较时交叉相乘，**但一定要注意不等号反向的问题！**</span><br><span class="line"></span><br><span class="line">同时还能解决分母可能为 $ 0 $ 的问题。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>
<p>然后，就好了！</p>
<div class="tabs" id="两种解决方案修复版"><ul class="nav-tabs"><li class="tab"><a href="#两种解决方案修复版-1">方法一修复版</a></li><li class="tab"><a href="#两种解决方案修复版-2">方法二修复版</a></li></ul><div class="tab-content"><div class="tab-pane" id="两种解决方案修复版-1"><p>开 <code>long double</code> 或者写高精度，不推荐。</p>
<p>但一般不卡精度时直接除就可以了。</p></div><div class="tab-pane" id="两种解决方案修复版-2"><p>像上文的代码那样写一个分子函数一个分母函数，比较时交叉相乘，<strong>但一定要注意不等号反向的问题！</strong></p>
<p>同时还能解决分母可能为 $ 0 $ 的问题。</p></div></div></div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>hexo or next 配置</category>
        <category>bug 修复 or 新的配置</category>
      </categories>
      <tags>
        <tag>bug 的修复</tag>
        <tag>hexo or next</tag>
      </tags>
  </entry>
  <entry>
    <title>一个有趣的对称</title>
    <url>/2024/05/28/%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E5%AF%B9%E7%A7%B0/</url>
    <content><![CDATA[<p>在做一道题：</p>
<blockquote>
<p>直线 <span class="math inline">\(l_1\)</span> 与 <span class="math inline">\(l_2\)</span> 关于 <span class="math inline">\(y=x\)</span> 对称，其中 <span class="math inline">\(l_1:\ y=3x-b,\ l2:\ y=ax+2\)</span>，问 <span class="math inline">\(a=?,b=?\)</span>。</p>
</blockquote>
<p>我不太会，于是请教了 lqs。</p>
<h4 id="他讲的内容">他讲的内容</h4>
<p><span class="math display">\[
y=ax+b
\]</span></p>
<p>对称后应是</p>
<p><span class="math display">\[
x=ay+b
\]</span></p>
<p>一些计算后，变为：</p>
<p><span class="math display">\[
y=\frac{1}{a}x-\frac{b}{a}
\]</span></p>
<p>所以，原题中 <span class="math inline">\(a=\frac{1}{3},b=6\)</span>。</p>
<h4 id="desmos-程序演示">desmos 程序演示</h4>
<p><a href="https://www.desmos.com/calculator/fgaxpmba9v?lang=zh-CN">体验地址</a>。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数学</category>
        <category>函数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/04/18/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
</search>
