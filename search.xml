<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>next 自带 tab 的 bug 修复</title>
    <url>/2024/05/30/next-%E8%87%AA%E5%B8%A6-tab-%E7%9A%84-bug-%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<p><a href="https://theme-next.js.org/docs/tag-plugins/tabs">我们知道，next
自带了一个东西叫 tabs</a>。</p>
<p>然而它有点 bug。</p>
<p>如果你用 mathjax 渲染，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% tabs 两种解决方案, -1 %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 方法一 --&gt;</span><br><span class="line"></span><br><span class="line">开 `long double` 或者写高精度，不推荐。</span><br><span class="line"></span><br><span class="line">但一般不卡精度时直接除就可以了。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 方法二 --&gt;</span><br><span class="line"></span><br><span class="line">像上文的代码那样写一个分子函数一个分母函数，比较时交叉相乘，**但一定要注意不等号反向的问题！**</span><br><span class="line"></span><br><span class="line">同时还能解决分母可能为 $0$ 的问题。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>
<p>渲染完毕，点开“方法二”，我们发现那个 <code>$0$</code>
没渲染出来。（不知道咋的在这里没了，但在其他地方不加下方的更改还有，大家可以自己试试）</p>
<p>翻了翻源码，发现似乎这里的源码不太一样：</p>
<p>正常的：<code>&lt;span class="math inline"&gt;\(0\)&lt;/span&gt;</code></p>
<p>这里的：<code>&lt;span class="math inline"&gt;(0)&lt;/span&gt;</code></p>
<p>于是我想到在那个 <code>$0$</code> 左右加空格，变成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% tabs 两种解决方案修复版, -1 %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 方法一修复版 --&gt;</span><br><span class="line"></span><br><span class="line">开 `long double` 或者写高精度，不推荐。</span><br><span class="line"></span><br><span class="line">但一般不卡精度时直接除就可以了。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 方法二修复版 --&gt;</span><br><span class="line"></span><br><span class="line">像上文的代码那样写一个分子函数一个分母函数，比较时交叉相乘，**但一定要注意不等号反向的问题！**</span><br><span class="line"></span><br><span class="line">同时还能解决分母可能为 $ 0 $ 的问题。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>
<p>然后，就好了！</p>
<div class="tabs" id="两种解决方案修复版"><ul class="nav-tabs"><li class="tab"><a href="#两种解决方案修复版-1">方法一修复版</a></li><li class="tab"><a href="#两种解决方案修复版-2">方法二修复版</a></li></ul><div class="tab-content"><div class="tab-pane" id="两种解决方案修复版-1"><p>开 <code>long double</code> 或者写高精度，不推荐。</p>
<p>但一般不卡精度时直接除就可以了。</p></div><div class="tab-pane" id="两种解决方案修复版-2"><p>像上文的代码那样写一个分子函数一个分母函数，比较时交叉相乘，<strong>但一定要注意不等号反向的问题！</strong></p>
<p>同时还能解决分母可能为 $ 0 $ 的问题。</p></div></div></div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>hexo or next 配置</category>
        <category>bug 修复 or 新的配置</category>
      </categories>
      <tags>
        <tag>bug 的修复</tag>
        <tag>hexo or next</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC 356 题解</title>
    <url>/2024/06/02/ABC-356-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="c">C</h3>
<h4 id="题目大意">题目大意</h4>
<p>有 <span class="math inline">\(N\)</span> 个编号分别为 <span class="math inline">\(1, 2, \dots, N\)</span> 的钥匙。</p>
<p>其中一些是真钥匙，其他的都是假钥匙。</p>
<p>有一扇门，你可以插入任意数量的钥匙。</p>
<p>只有插入至少 <span class="math inline">\(K\)</span>
把真钥匙，门才会打开。</p>
<p>已经对这些钥匙进行了 <span class="math inline">\(M\)</span>
次测试。</p>
<p>其中，第 <span class="math inline">\(i\)</span> 次测试过程如下：</p>
<ul>
<li>将 <span class="math inline">\(C_i\)</span> 把钥匙，分别是 <span class="math inline">\(A_{i,1}, A_{i,2}, \dots, A_{i,C_i}\)</span>
插入门。</li>
<li>测试结果用一个英文字母 <span class="math inline">\(R_i\)</span>
表示。
<ul>
<li><span class="math inline">\(R_i=\)</span> <code>o</code> 表示在第
<span class="math inline">\(i\)</span> 次测试中门打开了。</li>
<li><span class="math inline">\(R_i=\)</span> <code>x</code> 表示在第
<span class="math inline">\(i\)</span> 次测试中门没有打开。</li>
</ul></li>
</ul>
<p>有 <span class="math inline">\(2^N\)</span>
种可能的钥匙组合，在这些组合中，你需要找出与任何测试结果都不矛盾的组合数。</p>
<p>给定的测试结果有可能是错误的，没有任何组合满足条件。在这种情况下，输出
<span class="math inline">\(0\)</span>。</p>
<h4 id="思路">思路</h4>
<p>就是暴力，但赛时时间复杂度分析错误（我以为是 <span class="math inline">\(2^n\times n\times m\times k\)</span>，实际应是
<span class="math inline">\(2^n\times n\times
m\)</span>），导致没做出来。</p>
<p>实际极限情况运算次数约为 <span class="math inline">\(2^{15}\times
15\times 100=49152000\approx 5\times 10^7\)</span>，可以通过。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> esp 1e-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 999999999999999999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b,g) for(LL i=a;i&lt;=b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rem(i,a,b,g) for(LL i=a;i&gt;=b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> repn(i,a,b,g) for(LL i=a;i&lt;b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> remn(i,a,b,g) for(LL i=a;i&gt;b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;LL,LL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mkp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i128 __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(i128 &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i128 f=<span class="number">1</span>;</span><br><span class="line">	x=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writing</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">10</span>)<span class="built_in">writing</span>(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">		x=-x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">writing</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">LL n,m,k,c[<span class="number">110</span>],a[<span class="number">110</span>][<span class="number">20</span>],s;</span><br><span class="line">LL f[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> r[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==n+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,m,<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LL sum=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">rep</span>(j,<span class="number">1</span>,c[i],<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				sum+=f[a[i][j]];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!((sum&gt;=k&amp;&amp;r[i]==<span class="string">&#x27;o&#x27;</span>)||(sum&lt;k&amp;&amp;r[i]==<span class="string">&#x27;x&#x27;</span>)))<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		s++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(x+<span class="number">1</span>);</span><br><span class="line">	f[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(x+<span class="number">1</span>);</span><br><span class="line">	f[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;c[i];</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,c[i],<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		cin&gt;&gt;r[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h3 id="d">D</h3>
<h4 id="题目大意-1">题目大意</h4>
<p>给定整数 <span class="math inline">\(N\)</span> 和 <span class="math inline">\(M\)</span> ，计算 <span class="math inline">\(\displaystyle \sum_{k=0}^{N}\)</span> <span class="math inline">\(\rm{popcount}\)</span> <span class="math inline">\((k \mathbin{\&amp;} M)\)</span> 模 <span class="math inline">\(998244353\)</span> 的结果。</p>
<h4 id="思路-1">思路</h4>
<p>赛时没有一点思路，反映出我位运算练的少。</p>
<p>建议大家阅读<a href="https://atcoder.jp/contests/abc356/editorial/10144">官方题解</a>，比较清晰，而且可以提升英语阅读能力。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> esp 1e-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 999999999999999999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b,g) for(LL i=a;i&lt;=b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rem(i,a,b,g) for(LL i=a;i&gt;=b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> repn(i,a,b,g) for(LL i=a;i&lt;b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> remn(i,a,b,g) for(LL i=a;i&gt;b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;LL,LL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mkp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i128 __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(i128 &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i128 f=<span class="number">1</span>;</span><br><span class="line">	x=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writing</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">10</span>)<span class="built_in">writing</span>(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">		x=-x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">writing</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">LL n,m,sum;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(LL j,LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sum+=((n&gt;&gt;(j+<span class="number">1</span>))&lt;&lt;j);</span><br><span class="line">	sum%=MOD;</span><br><span class="line">	<span class="keyword">if</span>(n&amp;(<span class="number">1LL</span>&lt;&lt;j))</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=((n&amp;((<span class="number">1LL</span>&lt;&lt;j)<span class="number">-1</span>))+<span class="number">1</span>);</span><br><span class="line">		sum%=MOD;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="built_in">repn</span>(i,<span class="number">0</span>,<span class="number">60</span>,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(m&amp;(<span class="number">1LL</span>&lt;&lt;i))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">f</span>(i,n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>比赛</category>
        <category>ABC</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>ABC</tag>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/04/18/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>wqs 二分学习笔记</title>
    <url>/2024/06/02/wqs-%E4%BA%8C%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="前言">前言</h4>
<p>大家注意到本文 tags 和 categories 有 “优化” 和 “DP”，因为 wqs
二分确实可以优化 DP。</p>
<p>另外，部分讲解 wqs 二分的博客有讲到斜率之类的东西，于是我询问机房同学
zsw
“我看到我们学的时候有讲到斜率，但我觉得不用斜率也能理解，你觉得如何？”</p>
<blockquote>
<p>“当时课上那道黑白边最短路我讲的时候用了斜率，不用斜率我觉得会难理解一点，但其实我没注意。”zsw
如是说</p>
</blockquote>
<p>而且我看到他的代码有用到 <code>slope</code> 这一变量名。</p>
<p>于是我也写上了斜率。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>DP</category>
        <category>DP 优化</category>
        <category>wqs 二分</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>wqs 二分</tag>
        <tag>DP</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>一个有趣的对称</title>
    <url>/2024/05/28/%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E5%AF%B9%E7%A7%B0/</url>
    <content><![CDATA[<p>在做一道题：</p>
<blockquote>
<p>直线 <span class="math inline">\(l_1\)</span> 与 <span class="math inline">\(l_2\)</span> 关于 <span class="math inline">\(y=x\)</span> 对称，其中 <span class="math inline">\(l_1:\ y=3x-b,\ l2:\ y=ax+2\)</span>，问 <span class="math inline">\(a=?,b=?\)</span>。</p>
</blockquote>
<p>我不太会，于是请教了 lqs。</p>
<h4 id="他讲的内容">他讲的内容</h4>
<p><span class="math display">\[
y=ax+b
\]</span></p>
<p>对称后应是</p>
<p><span class="math display">\[
x=ay+b
\]</span></p>
<p>一些计算后，变为：</p>
<p><span class="math display">\[
y=\frac{1}{a}x-\frac{b}{a}
\]</span></p>
<p>所以，原题中 <span class="math inline">\(a=\frac{1}{3},b=6\)</span>。</p>
<h4 id="desmos-程序演示">desmos 程序演示</h4>
<p><a href="https://www.desmos.com/calculator/fgaxpmba9v?lang=zh-CN">体验地址</a>。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数学</category>
        <category>函数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>决策单调性 DP</title>
    <url>/2024/05/30/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7%20DP/</url>
    <content><![CDATA[<p>请注意，本篇博客<strong>不会讲解决策单调性 DP
及四边形不等式的基本原理等</strong>，主要是为了解决目前网上学习笔记多且清晰（如<a href="https://www.luogu.com/article/95ahsmez">whl
的学习笔记</a>）但例题讲解相对较晦涩的问题。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>DP</category>
        <category>DP 优化</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>DP</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>重修：数位统计 DP</title>
    <url>/2024/05/20/%E9%87%8D%E4%BF%AE-%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1DP/</url>
    <content><![CDATA[
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>DP</category>
        <category>DP 优化</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>DP</tag>
        <tag>优化</tag>
        <tag>重修</tag>
      </tags>
  </entry>
  <entry>
    <title>单调队列 &amp; 斜率优化 DP 学习笔记</title>
    <url>/2024/05/11/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96-%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96DP/</url>
    <content><![CDATA[<p>UpDate on 2024/5/23 代码增加一点注释</p>
<p>UpDate on 2024/5/28 增加一个同学写的反思</p>
<p>UpDate on 2024/5/29 写完单调队列优化多重背包部分</p>
<p>UpDate on 2024/5/31 单调队列优化多重背包部分添加代码</p>
<h4 id="单调队列优化-dp">单调队列优化 DP</h4>
<h5 id="单调队列">单调队列</h5>
<p>注意，其与优先队列不是同一种数据结构。（其实也不是严格的队列）</p>
<p><a href="https://www.luogu.com.cn/problem/P1886">其模板题</a>。</p>
<p>每当一个新的数加入，当队尾大于等于/小于等于（取决于每一道题目）这个数时，弹出队尾（因此这不是严格的队列）并继续比较直到队尾不满足其大于等于/小于等于这个数或队列空。然后将这个数加入队尾。</p>
<p>还有一个操作：当队头不优时，弹出队头。</p>
<h5 id="似乎无法优化-dp">似乎无法优化 DP？</h5>
<p><a href="https://www.luogu.com.cn/problem/CF372C">例题</a></p>
<p>状态设计可以想到是当放第 <span class="math inline">\(i\)</span>
个烟花的时候你在 <span class="math inline">\(j\)</span>
位置能获得的最大开心度。</p>
<p>转移方程依据题意，是 <span class="math display">\[
f_{i,j}=\max\lbrace f_{i-1,k}+b_i-|a_i-j|\rbrace
\]</span> <details class="note info no-icon"><summary><p>此处 <span class="math inline">\(k\)</span> 范围</p>
</summary>
<p><span class="math display">\[
j-(t_i-t_{i-1})\times d\le k \le j+(t_i-t_{i-1})\times d
\]</span></p>

</details></p>
<p>然而会超时，考虑优化。</p>
<p>但是，这坨式子很明显无法单调队列优化，其他优化似乎也不行。</p>
<h5 id="一个想法">一个想法</h5>
<p>暴力是三层循环，第一层 <span class="math inline">\(i\)</span>，第二层
<span class="math inline">\(j\)</span>，第三层 <span class="math inline">\(k\)</span>（因为 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 决定 <span class="math inline">\(k\)</span> 的范围）。</p>
<p>转移在 <span class="math inline">\(k\)</span> 层进行。</p>
<p>此时 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 已经固定，所以： <span class="math display">\[
f_{i,j}=\max\lbrace f_{i-1,k}\rbrace+b_i-|a_i-j|
\]</span> 既然 <span class="math inline">\(+b_i-|a_i-j|\)</span>
影响单调队列，我们就提出去！</p>
<p>于是时间复杂度降到 <span class="math inline">\(O(nm)\)</span>。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code from OI-wiki
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">150000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxm = <span class="number">300</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll f[<span class="number">2</span>][maxn];</span><br><span class="line">ll a[maxm], b[maxm], t[maxm];</span><br><span class="line"><span class="type">int</span> n, m, d;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> que[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fl = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">207</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">  <span class="built_in">memset</span>(que, <span class="number">0</span>, <span class="built_in">sizeof</span>(que));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">  fl = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;  <span class="comment">// 在这里使用了单调队列的优化，推式子详见上面</span></span><br><span class="line">      <span class="keyword">for</span> (; k &lt;= <span class="built_in">min</span>(<span class="number">1ll</span> * n, j + d * (t[i] - t[i - <span class="number">1</span>])); k++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; f[fl ^ <span class="number">1</span>][que[r]] &lt;= f[fl ^ <span class="number">1</span>][k]) r--;</span><br><span class="line">        que[++r] = k;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (l &lt;= r &amp;&amp; que[l] &lt; <span class="built_in">max</span>(<span class="number">1ll</span>, j - d * (t[i] - t[i - <span class="number">1</span>]))) l++;</span><br><span class="line">      f[fl][j] = f[fl ^ <span class="number">1</span>][que[l]] - <span class="built_in">abs</span>(a[i] - j) + b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fl ^= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; t[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// then dp</span></span><br><span class="line">  <span class="built_in">dp</span>();</span><br><span class="line">  ll ans = <span class="number">-1e18</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = <span class="built_in">max</span>(ans, f[fl ^ <span class="number">1</span>][i]);</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h5 id="多重背包的单调队列优化">多重背包的单调队列优化</h5>
<p>写一些我的见解吧。</p>
<p>这应该是多重背包的最优解了。</p>
<p><a href="https://www.luogu.com.cn/problem/P1776">例题</a>。</p>
<p>我们知道，暴力的转移方程是：</p>
<p><span class="math display">\[
dp_j=max\{dp_{j-kc_i}+kw_i\}
\]</span></p>
<p>其中 <span class="math inline">\(1\le k \le
min\{m_i,\frac{j}{c_i}\}\)</span>。</p>
<div class="note primary"><p>特别提一下，我这里的各个变量和数组与原题不同，物品个数是 <span class="math inline">\(n\)</span>，体积是 <span class="math inline">\(c_i\)</span>，价值是 <span class="math inline">\(w_i\)</span>，有 <span class="math inline">\(m_i\)</span> 个，背包大小是 <span class="math inline">\(C\)</span>。</p>
</div>
<p>打暴力的代码的话，是三层循环，我们发现 <span class="math inline">\(i,j\)</span> 之间没有关系，但是 <span class="math inline">\(j,k\)</span> 有关系，<span class="math inline">\(k\)</span> 在 <span class="math inline">\(j\)</span> 上有滑动窗口。</p>
<p>看似无法应用单调队列。</p>
<p>但是，我们发现：<span class="math inline">\(j+m\times
c_i=j+(m+p)\times c_i-p\times c_i\)</span>。</p>
<p>所以我们可以想到，当某些 <span class="math inline">\(j\)</span>
除以某个 <span class="math inline">\(c_i\)</span> 的余数相同时，他们的
<span class="math inline">\(k\)</span> 会有重叠。</p>
<p>那么，我们设 <span class="math inline">\(j=yc_i+b\)</span>，其中
<span class="math inline">\(b\)</span> 为余数（<span class="math inline">\(j\bmod c_i\)</span>），<span class="math inline">\(y=\lfloor\frac{j}{c_i}\rfloor\)</span>。</p>
<p>带入，原方程变为：</p>
<p><span class="math display">\[
dp_{yc_i+b}=max\{dp_{b+(y-k)c_i}+kw_i\}
\]</span></p>
<p>我们发现它看上去还是不能优化。</p>
<p>然而我们可以令 <span class="math inline">\(x=y-k\)</span>，此时方程变为：</p>
<p><span class="math display">\[
dp_{yc_i+b}=max\{dp_{b+xc_i}-xw_i+yw_i\}
\]</span></p>
<p>然后就能单调队列优化了。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code by whl(I improved its code style and added some annotations)
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL N=<span class="number">4e4</span>+<span class="number">10</span>;</span><br><span class="line">LL n,m,v,w,c,q[N],hh,tt,f[N],g[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(n--)<span class="comment">//输入时直接处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;v,&amp;w,&amp;c);</span><br><span class="line">        <span class="built_in">memcpy</span>(g,f,<span class="built_in">sizeof</span>(f));<span class="comment">//滚动数组的一种实现方式，上文的方程等都用了滚动数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;w;i++)<span class="comment">//余数，所以是 [0,w)</span></span><br><span class="line">        &#123;</span><br><span class="line">            hh=<span class="number">0</span>;</span><br><span class="line">            tt=<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//单调队列，这样等价于 h=1,t=0</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=m;j+=w)<span class="comment">//将这个余数的所有状态更新</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(hh&lt;=tt&amp;&amp;q[hh]&lt;j-w*c)hh++;<span class="comment">//个数超了 c</span></span><br><span class="line">                <span class="keyword">while</span>(hh&lt;=tt&amp;&amp;g[q[tt]]-v*q[tt]/w&lt;=g[j]-v*j/w)tt--;<span class="comment">//队尾没有 j 优</span></span><br><span class="line">                q[++tt]=j;</span><br><span class="line">                f[j]=g[q[hh]]+v*((j-q[hh])/w);<span class="comment">//转移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,f[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h4 id="斜率优化参考了罗勇军郭卫斌的算法竞赛">斜率优化！（参考了罗勇军、郭卫斌的《算法竞赛》）</h4>
<p>有一种 DP 转移方程： <span class="math display">\[
dp_i=\min\{dp_j-a_id_j\}(0\le j&lt;i,d_j\le d_{j+1},a_i\le a_{i+1})
\]</span> 朴素的去 DP，<span class="math inline">\(O(n^2)\)</span>。</p>
<h5 id="转换">转换</h5>
<p>把 <span class="math inline">\(i\)</span> 看作不变的常量。</p>
<p>把除了 <span class="math inline">\(dp_i\)</span> 以外的所有与 <span class="math inline">\(i\)</span> 有关的项看作常量。</p>
<p>把 <span class="math inline">\(j\)</span> 看作变量。</p>
<p>要求 <span class="math inline">\(j\)</span> 变化时 <span class="math inline">\(dp_i\)</span> 的最优值。</p>
<p>把 <span class="math inline">\(\min\)</span> 去掉，就变成了： <span class="math display">\[
dp_j=a_id_j+dp_i
\]</span> 为了让它看着像一次函数（才能求斜率），设 <span class="math inline">\(y=dp_j,x=d_j,k=a_i,b=dp_i\)</span>。</p>
<p>原式变为 <span class="math inline">\(y=kx+b\)</span>。</p>
<p>斜率优化需要满足几个条件：</p>
<ol type="1">
<li><p><span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 与 <span class="math inline">\(j\)</span> 有关，且只有 <span class="math inline">\(y\)</span> 中包含 <span class="math inline">\(dp_j\)</span>。于是 <span class="math inline">\((x,y)\)</span> 这个点就是一种决策。</p></li>
<li><p>斜率 <span class="math inline">\(k\)</span>、截距 <span class="math inline">\(b\)</span> 与 <span class="math inline">\(i\)</span> 有关，并且只有 <span class="math inline">\(b\)</span> 中含 <span class="math inline">\(dp_i\)</span>，其中最小的 <span class="math inline">\(b\)</span> 包含最小的 <span class="math inline">\(dp_i\)</span>，也就是转移方程的解。</p></li>
</ol>
<p><span class="math inline">\((x_1,y_1)\)</span> 和 <span class="math inline">\((x_2,y_2)\)</span> 这两个点组成的直线的斜率为
<span class="math inline">\((y_2-y_1)/(x_2-x_1)\)</span>，我们会发现这个斜率<strong>只与
<span class="math inline">\(j\)</span>
有关</strong>，于是可以用单调队列！</p>
<div class="note warning"><p>还有一点，<span class="math inline">\(x\)</span> 与 <span class="math inline">\(k\)</span> 要单调增加。</p>
<p>具体来说：<span class="math inline">\(x\)</span> 随 <span class="math inline">\(j\)</span> 递增而递增，<span class="math inline">\(k\)</span> 随 <span class="math inline">\(i\)</span> 递增而递增。</p>
</div>
<h5 id="求某个-dp_i">求某个 <span class="math inline">\(dp_i\)</span></h5>
<p>我们要求最优点，设它为 <span class="math inline">\(v\)</span>。</p>
<p>利用“下凸壳”。</p>
<p>如果这次转移的各个点（决策）是这样的：</p>
<p><img src="https://cppomstar.github.io/images/xielvDPno1.png"></p>
<p>上凸壳就是 <span class="math inline">\(2,3,4\)</span>。</p>
<p>我们可以发现：经过上凸壳<strong>中间那个点</strong>（即 <span class="math inline">\(3\)</span>）的直线的截距（<span class="math inline">\(b\)</span>）一定大于（《算法竞赛》中此处为“小于”，应为笔误）<span class="math inline">\(2\)</span> 和 <span class="math inline">\(4\)</span> 的直线的截距，于是 <span class="math inline">\(3\)</span>
一定不是最终的最优的点，去掉（绿色代表删掉了）：</p>
<p><img src="https://cppomstar.github.io/images/xielvDPno2.png"></p>
<p>剩的点都满足下凸壳关系（<span class="math inline">\(12\)</span>
的斜率小于 <span class="math inline">\(24\)</span> 的斜率）。</p>
<p>假设在这里面 <span class="math inline">\(12\)</span> 的斜率小于 <span class="math inline">\(k\)</span>，<span class="math inline">\(34\)</span> 的斜率大于 <span class="math inline">\(k\)</span>，那么最优点就是 <span class="math inline">\(2\)</span>（如下图，蓝色直线即为斜率为 <span class="math inline">\(k\)</span> 的直线）。</p>
<p><img src="https://cppomstar.github.io/images/xielvDPno3.png"></p>
<p>我们发现这部分用单调队列做非常容易。</p>
<h6 id="入队">入队</h6>
<p>我们现在要处理一个斜率：<span class="math inline">\((y_2-y_1)/(x_2-x_1)\)</span>。</p>
<p>斜率要<strong>单调上升</strong>，因为是下凸壳。</p>
<p>如果准备进队了发现斜率不单调上升，就把前面弹走。</p>
<p>每次进队后就大致像下图的结构（By OI Painter）：</p>
<p><img src="https://cppomstar.github.io/images/xielvDPno4.png"></p>
<h6 id="出队">出队</h6>
<p>注意，这说的是前面提到的“当队头不优时，弹出队头”。</p>
<p>设队头的两个点分别是 <span class="math inline">\(v_1\)</span> 和
<span class="math inline">\(v_2\)</span>。</p>
<p>如果 <span class="math inline">\(v_1v_2\)</span>
这条线段的斜率小于<strong>等于</strong>（我认为此处应该有等于，因为我们的条件是“左边的斜率小于
<span class="math inline">\(k\)</span>，右边的的斜率大于 <span class="math inline">\(k\)</span>”） <span class="math inline">\(k\)</span>，就可以把 <span class="math inline">\(v_1\)</span> 弹出去了（如上，不可能最优）。</p>
<p>然后一直弹，弹到 <span class="math inline">\(v_1v_2\)</span>
这条线段的斜率大于 <span class="math inline">\(k\)</span>，此时队头就是这个 <span class="math inline">\(dp_i\)</span> 的最优点。</p>
<h5 id="快速地求所有的-dp_i">（快速地）求所有的 <span class="math inline">\(dp_i\)</span></h5>
<p>然而我们会发现一个显著的问题：</p>
<details class="note danger"><summary><p>问题</p>
</summary>
<p>求一个 <span class="math inline">\(dp_i\)</span> 是 <span class="math inline">\(O(n)\)</span> 的。</p>
<p>求所有的是 <span class="math inline">\(O(n^2)\)</span> 的。</p>
<p>那这和暴力似乎没有区别。</p>

</details>
<p>我们来列一下各个 <span class="math inline">\(dp_i\)</span>
要处理的决策点：</p>
<p>举个例子，有两个数，<span class="math inline">\(j\)</span> 和 <span class="math inline">\(o\)</span>。</p>
<p>不妨设 <span class="math inline">\(j&lt;o\)</span>。</p>
<p><span class="math inline">\(dp_j\)</span>
要处理的之前的决策点是：</p>
<p><span class="math display">\[
{v_0,v_1,\dots,s_j}
\]</span></p>
<p><span class="math inline">\(dp_o\)</span>
要处理的之前的决策点是：</p>
<p><span class="math display">\[
{v_0,v_1,\dots,s_j,\dots,s_o}
\]</span></p>
<p>前面的 <span class="math inline">\({v_0,v_1,\dots,s_j}\)</span>
是重复的，可以避免这些重复的扫描。</p>
<details class="note info"><summary><p>方法</p>
</summary>
<p>《算法竞赛》上我觉得讲麻烦了，我讲一下我的想法：</p>
<p>我们前文保证过“<span class="math inline">\(x\)</span> 与 <span class="math inline">\(k\)</span> 单调增加”，于是 <span class="math inline">\(k_o\)</span> 的斜率一定大于 <span class="math inline">\(k_j\)</span> 的。</p>
<p>于是我们只用一个单调队列从头到尾处理即可，每次处理完剩下的数据后一个位置还能用。</p>
<p>时间复杂度骤降至 <span class="math inline">\(O(n)\)</span>。</p>

</details>
<p>核心代码如下：</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        main code
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(h&lt;t&amp;&amp;slope<span class="comment">/*斜率函数，但这个词一般表示“斜坡”*/</span>(q[h],q[h+<span class="number">1</span>])&lt;k)h++;</span><br><span class="line">    dp[i]=<span class="comment">/*状态转移方程*/</span>;</span><br><span class="line">    <span class="keyword">while</span>(h&lt;t&amp;&amp;<span class="built_in">slope</span>(i,q[t<span class="number">-1</span>])&lt;<span class="built_in">slope</span>(q[t<span class="number">-1</span>],q[t]))t--;</span><br><span class="line">    q[++t]=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p>然而我想说点有关代码的事：</p>
<details class="note success"><summary><p>既然写到了代码</p>
</summary>
<p>首先要有一个良好的代码习惯，比如记住上面那个代码，当作模板；</p>
<p>第二是我个人倡导的把大括号写开，即：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="comment">/*...*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*do sth*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而不是用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="comment">/*...*/</span>)&#123;</span><br><span class="line">    <span class="comment">/*do sth*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者其他难以找到这个大括号对应的前面的或后面的在哪、难以调试的代码风格。</p>
<p>这样可以更好地调试，也可以有更好的心态（这是作为 OIer
很重要的一点）。</p>
<p>第三就是如果遇到毒瘤出题人卡精度，使用 <code>slope</code>
会有精度误差时，可以像我的同学 ly 那样写一个 <code>slope_fz</code> 和
<code>slope_fm</code> 函数，比较时就交叉相乘。</p>

</details>
<h5 id="例题"><a href="https://www.acwing.com/problem/content/description/4841/">例题</a></h5>
<p>设 <span class="math inline">\(f_i\)</span> 表示输出前 <span class="math inline">\(i\)</span> 个单词的最少费用，那么根据题意，我们设
<span class="math inline">\(s_i\)</span> 表示前 <span class="math inline">\(i\)</span> 个单词的费用之和。</p>
<p>转移方程就是：</p>
<p><span class="math display">\[
dp_i=\min\{dp_j+(s_i-s_j)^2+M\}
\]</span></p>
<p>其中 <span class="math inline">\(1\le j&lt;i\)</span>。</p>
<p>中间过程大致如下：</p>
<p>展开、移项（对照 <span class="math inline">\(y=kx+b\)</span>
的格式和要求），得：</p>
<p><span class="math display">\[
dp_j+{s_j}^2=2s_is_j+dp_i-{s_i}^2-M
\]</span></p>
<p>那么，<span class="math inline">\(y\)</span> 是 <span class="math inline">\(dp_j+{s_j}^2\)</span>，<span class="math inline">\(x\)</span> 是 <span class="math inline">\(2s_j\)</span>，<span class="math inline">\(k\)</span> 是 <span class="math inline">\(s_i\)</span>，<span class="math inline">\(b\)</span> 是 <span class="math inline">\(dp_i-{s_i}^2-M\)</span>，而且符合条件。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code by ly（I solved the bugs）
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll n,m,q[N],l,r;</span><br><span class="line">ll a[N],dp[N];</span><br><span class="line"><span class="function">ll <span class="title">get_x</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>*a[x];<span class="comment">//即 2*s[j]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">get_y</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dp[x]+a[x]*a[x];<span class="comment">//即 dp[j]+s[j]*s[j]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">slope_fz</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">get_y</span>(x)-<span class="built_in">get_y</span>(y);<span class="comment">//斜率的分子</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">slope_fm</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">get_x</span>(x)-<span class="built_in">get_x</span>(y);<span class="comment">//斜率的分母</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">	&#123;</span><br><span class="line">		l=<span class="number">0</span>;</span><br><span class="line">		r=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">		<span class="built_in">memset</span>(q,<span class="number">0</span>,<span class="built_in">sizeof</span>(q));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">			a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;r&amp;&amp;<span class="built_in">slope_fz</span>(q[l+<span class="number">1</span>],q[l])&lt;=(__int128)a[i]*<span class="built_in">slope_fm</span>(q[l+<span class="number">1</span>],q[l])) l++;</span><br><span class="line">			dp[i]=dp[q[l]]+m+(a[i]-a[q[l]])*(a[i]-a[q[l]]);<span class="comment">//注意，转移时还是按原转移方程进行转移</span></span><br><span class="line">			<span class="keyword">while</span>(l&lt;r&amp;&amp;(__int128)<span class="built_in">slope_fz</span>(i,q[r])*<span class="built_in">slope_fm</span>(q[r],q[r<span class="number">-1</span>])&lt;=(__int128)<span class="built_in">slope_fz</span>(q[r],q[r<span class="number">-1</span>])*<span class="built_in">slope_fm</span>(i,q[r])) r--;</span><br><span class="line">			q[++r]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp[n]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

    </div>
</div>
<div class="note success"><p>斜率优化的代码特别容易踩坑。</p>
<p>具体我目前知道的有：</p>
<ol type="1">
<li>数据卡精度</li>
</ol>
<div id="两种解决方案" class="tabs">
<ul class="nav-tabs">
<li class="tab">
<a href="#两种解决方案-1">方法一</a>
</li>
<li class="tab">
<a href="#两种解决方案-2">方法二</a>
</li>
</ul>
<div class="tab-content">
<div id="两种解决方案-1" class="tab-pane">
<p>
开 <code>long double</code> 或者写高精度，不推荐。
</p>
<p>
但一般不卡精度时直接除就可以了。
</p>
</div>
<div id="两种解决方案-2" class="tab-pane">
<p>
像上文的代码那样写一个分子函数一个分母函数，比较时交叉相乘，<strong>但一定要注意不等号反向的问题！</strong>
</p>
<p>
同时还能解决分母可能为 $ 0 $ 的问题。
</p>
</div>
</div>
</div>
<ol start="2" type="1">
<li>单调队列写挂（即我解决的 bug）（解决方案：写成上文代码那样的初始
<code>l=r=0</code> 用时 <code>l&lt;r</code>
单调队列，或者这么写，见下：）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*初始化*/</span></span><br><span class="line">l=<span class="number">1</span>;</span><br><span class="line">r=<span class="number">0</span>;</span><br><span class="line">q[++l]=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*用的时候*/</span></span><br><span class="line">l&lt;=r</span><br></pre></td></tr></table></figure>
<p>原因见<a href="https://www.luogu.com/article/lf5fferx">此</a>。</p>
</div>
<h4 id="小结">小结</h4>
<p>斜率优化可以算是比较高级的 DP 优化了。</p>
<p>有些别的优化时间复杂度比斜率优化劣，比如笔者 2024.5.19
写的一道题，四边形不等式 <span class="math inline">\(O(n\log
n)\)</span>，而斜率优化 <span class="math inline">\(O(n)\)</span>。</p>
<p>也可以找些习题进行练习，如 <a href="https://www.luogu.com.cn/problem/P5785" class="uri">https://www.luogu.com.cn/problem/P5785</a> 等。</p>
<p>另，由于本博客成文时间仓促，可能会有些错误，欢迎指出。</p>
<h4 id="致谢">致谢</h4>
<p>我学校的信息学教练 zxc，为此文提供了基础；</p>
<p>OI-wiki 斜率优化、单调队列优化部分编写人员及 OI-wiki
建设者，为本文提供代码及部分参考；</p>
<p>同学 whl，专门给我讲了一次斜率优化，并在 2024/5/31
提供单调队列优化多重背包例题代码；</p>
<p>同学
ly，提供例题代码（虽然我改了一点）、经典错误和其解决方案和反思；</p>
<p>OI Painter 开发者 EternalAlexander，提供一张图片的绘画支持；</p>
<p>tldraw 开发者，提供三张图片的绘画支持；</p>
<p>AcWing 站长 yxc，提供例题；</p>
<p>罗勇军、郭卫斌及其他《算法竞赛》编写、贡献者，为斜率优化部分提供参考。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>DP</category>
        <category>DP 优化</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>DP</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>查漏补缺：状压 DP</title>
    <url>/2024/05/20/%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E7%8A%B6%E5%8E%8B-DP/</url>
    <content><![CDATA[<p>To Do:</p>
<ul class="task-list">
<li><label><input type="checkbox" checked>关于它的中英文名</label></li>
<li><label><input type="checkbox" checked>例题引入</label></li>
<li><label><input type="checkbox">分析</label></li>
<li><label><input type="checkbox">代码</label></li>
<li><label><input type="checkbox">能直接用的二进制工具</label></li>
<li><label><input type="checkbox">（顺便提到，不会太多）三进制及其他进制状态压缩自己优化
DP</label></li>
<li><label><input type="checkbox">小结</label></li>
<li><label><input type="checkbox">致谢</label></li>
</ul>
<h4 id="状压的中英文名的研究">状压的中英文名的研究</h4>
<p>状压 DP 的英文是 DP on Subsets，但其实中英文都不够准确。</p>
<p>我认为最好的叫法是“状态压缩子集优化 DP”（简写时还是用“状压
DP”或“状压”），英文用 State-compressioned subsets optimization for DP
会好一点。</p>
<h4 id="从一道例题开始">从一道例题开始</h4>
<p><a href="https://www.acwing.com/problem/content/93/">Link</a>。</p>
<p>首先注意，不要妄想找到这题的<strong>多项式复杂度</strong>的解法，因为这是
NP 问题。</p>
<p>先想暴力怎么写，枚举全排列，我们知道一共有 <span class="math inline">\(n!\)</span>
种全排列，其中每个全排列就对应一种路径。</p>
<p>而计算路径长度，需要 <span class="math inline">\(O(n)\)</span>，总复杂度 <span class="math inline">\(O(n\times n!)\)</span>，在 <span class="math inline">\(n=20\)</span> 时，<span class="math inline">\(n\times
n!=48658040163532800000\)</span>，显然无法通过。</p>
<h5 id="用状压-dp-求解">用状压 DP 求解</h5>
<p>如果用状态压缩子集优化 DP，总复杂度为 <span class="math inline">\(O(n^2\times 2^n)\)</span>，在 <span class="math inline">\(n=20\)</span> 时，<span class="math inline">\(n^2\times 2^n\approx 4\times
10^8\)</span>，复杂度远优于暴力，可以通过。</p>
<p>我们设整个图的一个子集为 <span class="math inline">\(S\)</span>，且用
<span class="math inline">\(dp_{S,j}\)</span> 表示</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>DP</category>
        <category>DP 优化</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>DP</tag>
        <tag>优化</tag>
        <tag>查漏补缺</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树学习笔记</title>
    <url>/2024/04/25/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>请注意，本文默认大家学过单改区查的基础线段树（包括动态开点），若未学，请移步
<a href="https://oi-wiki.org/ds/seg/">OI-wiki</a>，例题可以使用树状数组的题目。</p>
<h3 id="区间修改懒标记lazy-tag">区间修改：懒标记（lazy-tag）</h3>
<details class="note info no-icon"><summary><p><a href="https://www.luogu.com.cn/problem/P3372">【模板】线段树
1</a></p>
</summary>
<p>题目描述</p>
<p>已知一个数列，你需要进行下面两种操作：</p>
<ol type="1">
<li>将某区间每一个数加上 <span class="math inline">\(k\)</span>。</li>
<li>求出某区间每一个数的和。</li>
</ol>
<p>输入格式</p>
<p>第一行包含两个整数 <span class="math inline">\(n,
m\)</span>，分别表示该数列数字的个数和操作的总个数。</p>
<p>第二行包含 <span class="math inline">\(n\)</span>
个用空格分隔的整数，其中第 <span class="math inline">\(i\)</span>
个数字表示数列第 <span class="math inline">\(i\)</span> 项的初始值。</p>
<p>接下来 <span class="math inline">\(m\)</span> 行每行包含 <span class="math inline">\(3\)</span> 或 <span class="math inline">\(4\)</span> 个整数，表示一个操作，具体如下：</p>
<ol type="1">
<li><code>1 x y k</code>：将区间 <span class="math inline">\([x,
y]\)</span> 内每个数加上 <span class="math inline">\(k\)</span>。</li>
<li><code>2 x y</code>：输出区间 <span class="math inline">\([x,
y]\)</span> 内每个数的和。</li>
</ol>
<p>输出格式</p>
<p>输出包含若干行整数，即为所有操作 2 的结果。</p>
<p>样例输入 #1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 5 4 2 3</span><br><span class="line">2 2 4</span><br><span class="line">1 2 3 2</span><br><span class="line">2 3 4</span><br><span class="line">1 1 5 1</span><br><span class="line">2 1 4</span><br></pre></td></tr></table></figure>
<p>样例输出 #1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br><span class="line">8</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<p>提示</p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据：<span class="math inline">\(1 \le n, m \le {10}^5\)</span>。</p>

</details>
<p>很明显，如果用暴力进行区间修改，不能通过。</p>
<p>那么引入 lazy-tag。</p>
<p>首先，先介绍 lazy-tag 的概念：</p>
<p>对于每个有 lazy-tag
的节点，在只有需要用到自己的子节点时才会把修改的命令（lazy-tag）交给子节点。</p>
<p>lazy-tag 用一个叫做 <code>push_down</code> 的操作下放修改操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">p_d_</span><span class="params">(<span class="type">long</span> <span class="type">long</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> L=u&lt;&lt;<span class="number">1</span>,R=u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">	t[L].sum+=t[u].y*(t[L].r-t[L].l+<span class="number">1</span>);<span class="comment">//处理左子树总和</span></span><br><span class="line">	t[R].sum+=t[u].y*(t[R].r-t[R].l+<span class="number">1</span>);<span class="comment">//右子树</span></span><br><span class="line">	t[L].y+=t[u].y;<span class="comment">//标记下放</span></span><br><span class="line">	t[R].y+=t[u].y;<span class="comment">//同上</span></span><br><span class="line">	t[u].y=<span class="number">0</span>;<span class="comment">//清零，代表下放结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>y</code> 就是 lazy-tag。</p>
<p>第二，<code>up_date</code> 函数在符合
<code>t[u].l&gt;=l&amp;&amp;t[u].r&lt;=r</code> 时，将 lazy-tag
加上此次加操作的值，并增加此区间总和。</p>
<p>若不符合，则进行 <code>push_down</code>
操作，为递归左右子树铺垫。</p>
<p>第三，<code>query</code> 函数在
<code>t[u].l&gt;=l&amp;&amp;t[u].r&lt;=r</code> 不成立时，也需进行
<code>push_down</code> 操作，原因同上。</p>
<p>显然，此时复杂度为 <span class="math inline">\(O(mlogn)\)</span></p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,m,x,y;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> k;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[<span class="number">500010</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> l,r,sum,y;</span><br><span class="line">&#125;t[<span class="number">500010</span>&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p_u_</span><span class="params">(<span class="type">long</span> <span class="type">long</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].sum=t[u&lt;&lt;<span class="number">1</span>].sum+t[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p_d_</span><span class="params">(<span class="type">long</span> <span class="type">long</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> L=u&lt;&lt;<span class="number">1</span>,R=u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">	t[L].sum+=t[u].y*(t[L].r-t[L].l+<span class="number">1</span>);</span><br><span class="line">	t[R].sum+=t[u].y*(t[R].r-t[R].l+<span class="number">1</span>);</span><br><span class="line">	t[L].y+=t[u].y;</span><br><span class="line">	t[R].y+=t[u].y;</span><br><span class="line">	t[u].y=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">b_</span><span class="params">(<span class="type">long</span> <span class="type">long</span> u,<span class="type">long</span> <span class="type">long</span> l,<span class="type">long</span> <span class="type">long</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].l=l,t[u].r=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].sum=a[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">b_</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">	<span class="built_in">b_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">p_u_</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">u_d_</span><span class="params">(<span class="type">long</span> <span class="type">long</span> u,<span class="type">long</span> <span class="type">long</span> l,<span class="type">long</span> <span class="type">long</span> r,<span class="type">long</span> <span class="type">long</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[u].l&gt;=l&amp;&amp;t[u].r&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].sum+=c*(t[u].r-t[u].l+<span class="number">1</span>);</span><br><span class="line">		t[u].y+=c;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">p_d_</span>(u);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> mid=(t[u].l+t[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)<span class="built_in">u_d_</span>(u&lt;&lt;<span class="number">1</span>,x,y,c);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) <span class="built_in">u_d_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y,c);</span><br><span class="line">	<span class="built_in">p_u_</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">q_</span><span class="params">(<span class="type">long</span> <span class="type">long</span> u,<span class="type">long</span> <span class="type">long</span> l,<span class="type">long</span> <span class="type">long</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=t[u].l&amp;&amp;r&gt;=t[u].r)<span class="keyword">return</span> t[u].sum;</span><br><span class="line">	<span class="built_in">p_d_</span>(u);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> mid=(t[u].l+t[u].r)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)ans+=<span class="built_in">q_</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)ans+=<span class="built_in">q_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">b_</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;k;</span><br><span class="line">		<span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">			<span class="built_in">u_d_</span>(<span class="number">1</span>,x,y,k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">			cout&lt;&lt;<span class="built_in">q_</span>(<span class="number">1</span>,x,y)&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h3 id="权值线段树">权值线段树</h3>
<p>普通的线段树，记录的是数组中当前区间的各种信息。</p>
<p>权值线段树，则记录的是每种数据出现的次数。</p>
<p>如：数组为 <code>1 1 4 5 1 4</code></p>
<p>则其出现次数为（从 <span class="math inline">\(0\)</span>
开始）<code>0 3 0 0 2 1</code>。</p>
<h3 id="线段树合并">线段树合并</h3>
<p>前置知识：权值线段树（一般线段树合并合并的是权值线段树）。</p>
<blockquote>
<p>线段树合并是指建立一棵新的线段树，这棵线段树的每个节点都是两棵原线段树对应节点合并后的结果。它常常被用于维护树上或是图上的信息。——OI
wiki</p>
</blockquote>
<p>如果每次合并都新开一棵满树，时间、空间都无法接受。</p>
<p>那么，就需要本文开头提到的前置知识动态开点。</p>
<p>设需要合并的两棵树分别叫 <span class="math inline">\(T1\)</span> 和
<span class="math inline">\(T2\)</span>。</p>
<p>从上往下（即从 <span class="math inline">\(1\)</span>
号节点开始递归向下），对于每个节点，若 <span class="math inline">\(T1\)</span> 上无此节点，就只加入 <span class="math inline">\(T2\)</span> 上的此节点。反之亦然。</p>
<p>如果都有此节点，若是叶子节点，直接合并所有信息。</p>
<p>若否，通过子节点的返回（返回左儿子、右儿子）更新。</p>
<p>OI-wiki
上对其时间复杂度的证明不严谨，读者可以在写的时候自己证其时间复杂度。</p>
<h3 id="扫描线">扫描线</h3>
<p>下面这张动图，诠释了这种算法在处理面积并上的的大致思路：（感谢
OI-wiki，面积并处理部分也请参见 OI-wiki）</p>
<p><img src="https://cppomstar.github.io//images/scanning.svg"></p>
<p>本博客则讲述其解决周长并上的解法，详见<a href="https://cppomstar.github.io/2024/04/25/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#t7">T7</a>。</p>
<h3 id="例题">例题</h3>
<h4 id="t1">T1</h4>
<p><img src="https://cppomstar.github.io//images/segtreeT1.png"></p>
<p>首先的思路是暴力（二维前缀和），然而会时间和空间超限。</p>
<p>优化：因为“星星按y坐标增序给出，y坐标相同的按x坐标增序给出”，所以只需查找从
<span class="math inline">\(0\)</span>
高度到此高度范围内共有多少颗星星（因为保证 <span class="math inline">\(y\)</span> 增序了），求和即可。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> esp 1e-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 999999999999999999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b,g) for(LL i=a;i&lt;=b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rem(i,a,b,g) for(LL i=a;i&gt;=b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> repn(i,a,b,g) for(LL i=a;i&lt;b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> remn(i,a,b,g) for(LL i=a;i&gt;b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;LL,LL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mkp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i128 __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(i128 &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i128 f=<span class="number">1</span>;</span><br><span class="line">	x=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writing</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">10</span>)<span class="built_in">writing</span>(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">		x=-x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">writing</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">LL n,x[<span class="number">1000010</span>],y[<span class="number">1000010</span>];</span><br><span class="line">LL k;</span><br><span class="line">LL a[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">	LL l,r,sum,y;</span><br><span class="line">&#125;t[<span class="number">1000010</span>&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p_u_</span><span class="params">(LL u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].sum=t[u&lt;&lt;<span class="number">1</span>].sum+t[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p_d_</span><span class="params">(LL u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL L=u&lt;&lt;<span class="number">1</span>,R=u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">	t[L].sum+=t[u].y*(t[L].r-t[L].l+<span class="number">1</span>);</span><br><span class="line">	t[R].sum+=t[u].y*(t[R].r-t[R].l+<span class="number">1</span>);</span><br><span class="line">	t[L].y+=t[u].y;</span><br><span class="line">	t[R].y+=t[u].y;</span><br><span class="line">	t[u].y=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">b_</span><span class="params">(LL u,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].l=l;</span><br><span class="line">	t[u].r=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LL mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">b_</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">	<span class="built_in">b_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">p_u_</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">u_d_</span><span class="params">(LL u,LL l,LL r,LL c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[u].l&gt;=l&amp;&amp;t[u].r&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].sum+=c*(t[u].r-t[u].l+<span class="number">1</span>);</span><br><span class="line">		t[u].y+=c;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">p_d_</span>(u);</span><br><span class="line">	LL mid=(t[u].l+t[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)<span class="built_in">u_d_</span>(u&lt;&lt;<span class="number">1</span>,l,r,c);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) <span class="built_in">u_d_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,c);</span><br><span class="line">	<span class="built_in">p_u_</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">q_</span><span class="params">(LL u,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=t[u].l&amp;&amp;r&gt;=t[u].r)<span class="keyword">return</span> t[u].sum;</span><br><span class="line">	<span class="built_in">p_d_</span>(u);</span><br><span class="line">	LL mid=(t[u].l+t[u].r)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)ans+=<span class="built_in">q_</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)ans+=<span class="built_in">q_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">LL sum[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">b_</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">320000</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LL u=x[i]+<span class="number">1</span>;</span><br><span class="line">		LL v=<span class="built_in">q_</span>(<span class="number">1</span>,<span class="number">1</span>,u);</span><br><span class="line">		<span class="built_in">u_d_</span>(<span class="number">1</span>,u,u,<span class="number">1</span>);</span><br><span class="line">		sum[v+<span class="number">1</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;sum[i]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h4 id="t2"><a href="https://www.luogu.com.cn/problem/P5057">T2</a></h4>
<p>很明显，因为是“区查单改”且是较为特殊的异或，我们需要把“异或次数”作为
lazy-tag。</p>
<p>同时因为只有 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(0\)</span>，所以 lazy-tag 每次异或（即 <span class="math inline">\(+1\bmod 2\)</span>）即可。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> esp 1e-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 999999999999999999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b,g) for(LL i=a;i&lt;=b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rem(i,a,b,g) for(LL i=a;i&gt;=b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> repn(i,a,b,g) for(LL i=a;i&lt;b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> remn(i,a,b,g) for(LL i=a;i&gt;b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;LL,LL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mkp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i128 LL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(i128 &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i128 f=<span class="number">1</span>;</span><br><span class="line">	x=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writing</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">10</span>)<span class="built_in">writing</span>(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">		x=-x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">writing</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">LL n,m,x,y,k,a[<span class="number">100010</span>],tt[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">	LL l,r,sum,y;</span><br><span class="line">&#125;t[<span class="number">100010</span>&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p_u_</span><span class="params">(LL u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].sum=t[u&lt;&lt;<span class="number">1</span>].sum+t[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p_d_</span><span class="params">(LL u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL L=u&lt;&lt;<span class="number">1</span>,R=u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">	t[L].sum=t[L].r-t[L].l+<span class="number">1</span>-t[L].sum;</span><br><span class="line">	t[R].sum=t[R].r-t[R].l+<span class="number">1</span>-t[R].sum;</span><br><span class="line">	t[L].y^=<span class="number">1</span>;</span><br><span class="line">	t[R].y^=<span class="number">1</span>;</span><br><span class="line">	t[u].y=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">b_</span><span class="params">(LL u,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].l=l,t[u].r=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].sum=tt[l<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LL mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">b_</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">	<span class="built_in">b_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">p_u_</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">u_d_</span><span class="params">(LL u,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[u].l&gt;=l&amp;&amp;t[u].r&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].sum=t[u].r-t[u].l+<span class="number">1</span>-t[u].sum;</span><br><span class="line">		t[u].y^=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t[u].y)<span class="built_in">p_d_</span>(u);</span><br><span class="line">	LL mid=(t[u].l+t[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)<span class="built_in">u_d_</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)<span class="built_in">u_d_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="built_in">p_u_</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">q_</span><span class="params">(LL u,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=t[u].l&amp;&amp;r&gt;=t[u].r)<span class="keyword">return</span> t[u].sum;</span><br><span class="line">	<span class="keyword">if</span>(t[u].y)<span class="built_in">p_d_</span>(u);</span><br><span class="line">	LL mid=(t[u].l+t[u].r)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)ans+=<span class="built_in">q_</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)ans+=<span class="built_in">q_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="built_in">b_</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(k);</span><br><span class="line">		<span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">read</span>(x);</span><br><span class="line">			<span class="built_in">read</span>(y);</span><br><span class="line">			<span class="built_in">u_d_</span>(<span class="number">1</span>,x,y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">read</span>(x);</span><br><span class="line">			y=x;</span><br><span class="line">			<span class="built_in">write</span>(<span class="built_in">q_</span>(<span class="number">1</span>,x,y));</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h4 id="t3"><a href="https://www.luogu.com.cn/problem/P4145">T3</a></h4>
<p>当然，“开方”操作的懒标记以及修改都很难做。</p>
<p>然而，我们发现：<span class="math inline">\(\Bigg \lfloor
\sqrt{\sqrt{\sqrt{\sqrt{\sqrt{\sqrt 10^{12}}}}}} \Bigg
\rfloor=1\)</span></p>
<p>所以就这样操作即可：不是全 <span class="math inline">\(0\)</span>
或全 <span class="math inline">\(1\)</span>，暴力；是，不管。</p>
<h4 id="t4"><a href="https://www.luogu.com.cn/problem/P3373">T4</a></h4>
<p>我们需要两个 lazy-tag，一个是乘的，一个是加的。</p>
<p>优先级是乘 <span class="math inline">\(&gt;\)</span>
加，因为加完再乘，加的那部分也要被乘，反之不然。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,p,opt,x,y,k;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">xds</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> l,r,sum,m,a;</span><br><span class="line">&#125;t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pu</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].sum=(t[u&lt;&lt;<span class="number">1</span>].sum+t[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> l=u&lt;&lt;<span class="number">1</span>,r=l|<span class="number">1</span>;</span><br><span class="line">	t[l].sum=(<span class="number">1ll</span>*t[l].sum*t[u].m+<span class="number">1ll</span>*(t[l].r-t[l].l+<span class="number">1</span>)*t[u].a)%p;</span><br><span class="line">	t[r].sum=(<span class="number">1ll</span>*t[r].sum*t[u].m+<span class="number">1ll</span>*(t[r].r-t[r].l+<span class="number">1</span>)*t[u].a)%p;</span><br><span class="line">	t[l].m=<span class="number">1ll</span>*t[l].m*t[u].m%p;</span><br><span class="line">	t[r].m=<span class="number">1ll</span>*t[r].m*t[u].m%p;</span><br><span class="line">	t[l].a=(<span class="number">1ll</span>*t[l].a*t[u].m+t[u].a)%p;</span><br><span class="line">	t[r].a=(<span class="number">1ll</span>*t[r].a*t[u].m+t[u].a)%p;</span><br><span class="line">	t[u].m=<span class="number">1</span>;</span><br><span class="line">	t[u].a=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">b</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].l=l;</span><br><span class="line">	t[u].r=r;</span><br><span class="line">	t[u].m=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].sum=a[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> z=t[u].l+t[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">b</span>(u&lt;&lt;<span class="number">1</span>,l,z);</span><br><span class="line">	<span class="built_in">b</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,z+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">pu</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mu</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[u].l&gt;=l&amp;&amp;t[u].r&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].sum=<span class="number">1ll</span>*t[u].sum*k%p;</span><br><span class="line">		t[u].m=<span class="number">1ll</span>*t[u].m*k%p;</span><br><span class="line">		t[u].a=<span class="number">1ll</span>*t[u].a*k%p;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t[u].m!=<span class="number">1</span>||t[u].a)<span class="built_in">pd</span>(u);</span><br><span class="line">	<span class="type">int</span> z=t[u].l+t[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=z)<span class="built_in">mu</span>(u&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;z)<span class="built_in">mu</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">	<span class="built_in">pu</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">au</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[u].l&gt;=l&amp;&amp;t[u].r&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].sum=(t[u].sum+<span class="number">1ll</span>*k*(t[u].r-t[u].l+<span class="number">1</span>))%p;</span><br><span class="line">		t[u].a=(t[u].a+k)%p;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t[u].m!=<span class="number">1</span>||t[u].a)<span class="built_in">pd</span>(u);</span><br><span class="line">	<span class="type">int</span> z=t[u].l+t[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=z)<span class="built_in">au</span>(u&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;z)<span class="built_in">au</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">	<span class="built_in">pu</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">q</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[u].l&gt;=l&amp;&amp;t[u].r&lt;=r)<span class="keyword">return</span> t[u].sum;</span><br><span class="line">	<span class="keyword">if</span>(t[u].m!=<span class="number">1</span>||t[u].a)<span class="built_in">pd</span>(u);</span><br><span class="line">	<span class="type">int</span> z=t[u].l+t[u].r&gt;&gt;<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=z)sum=(sum+<span class="built_in">q</span>(u&lt;&lt;<span class="number">1</span>,l,r))%p;</span><br><span class="line">	<span class="keyword">if</span>(r&gt;z) sum=(sum+<span class="built_in">q</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r))%p;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">b</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;opt;</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">			<span class="built_in">mu</span>(<span class="number">1</span>,x,y,k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">			<span class="built_in">au</span>(<span class="number">1</span>,x,y,k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">			cout&lt;&lt;<span class="built_in">q</span>(<span class="number">1</span>,x,y)&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h4 id="t5">T5</h4>
<details class="note info no-icon"><summary><p>工厂</p>
</summary>
<p>小明的叔叔是一家工厂的厂长。叔叔的工厂有 n 个车间，编号为 1～n。</p>
<p>管理工厂是很麻烦的事情，特别是在多次调整机器以及员工之后，统计总生产量更是难事。</p>
<p>第 i 个车间在刚开始的时候机器生产力为 ai，有 bi
个员工，那么这个车间的生产力就为ai*bi。</p>
<p>工厂的总生产力定义为所有车间的生产力之和。</p>
<p>接下来的 m 天，每天叔叔就会调整一段区间的车间。</p>
<p>有两种调整：</p>
<p>第一种，是对于一段区间[l,r]的每一个车间重新分配每个车间的工人数为
x。</p>
<p>第二种，是对于一段区间[l,r]的每一个车间增加机器生产力 x。</p>
<p>现在，小明的叔叔想知道每天调整之后工厂的生产量变为多少。</p>

</details>
<p>我们发现，这和 T4 很像，只是“加”变为了“覆盖”。</p>
<p>于是把“加” lazy-tag 变为“覆盖”的即可。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code(thanks to lqs)
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 400010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> esp 1e-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 999999999999999999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b,g) for(LL i=a;i&lt;=b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rem(i,a,b,g) for(LL i=a;i&gt;=b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> repn(i,a,b,g) for(LL i=a;i&lt;b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> remn(i,a,b,g) for(LL i=a;i&gt;b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;LL,LL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mkp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i128 __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (ls+1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lm (l+r&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rm (lm+1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(i128 &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i128 f=<span class="number">1</span>;</span><br><span class="line">	x=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writing</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">10</span>)<span class="built_in">writing</span>(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">		x=-x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">writing</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">LL n,q,s,t,d,a[N],b[N],ans[N],sa[N],sb[N],ta[N],tb[N];</span><br><span class="line">string op;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pu</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ans[x]=ans[ls]+ans[rs];</span><br><span class="line">	sa[x]=sa[ls]+sa[rs];</span><br><span class="line">	sb[x]=sb[ls]+sb[rs];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pd</span><span class="params">(LL x,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sa[ls]+=ta[x]*(lm-l+<span class="number">1</span>);</span><br><span class="line">	sa[rs]+=ta[x]*(r-rm+<span class="number">1</span>);</span><br><span class="line">	ta[ls]+=ta[x];</span><br><span class="line">	ta[rs]+=ta[x];</span><br><span class="line">	<span class="keyword">if</span>(tb[x])</span><br><span class="line">	&#123;</span><br><span class="line">		sb[ls]=tb[x]*(lm-l+<span class="number">1</span>);</span><br><span class="line">		sb[rs]=tb[x]*(r-rm+<span class="number">1</span>);</span><br><span class="line">		ans[ls]=tb[x]*sa[ls];</span><br><span class="line">		ans[rs]=tb[x]*sa[rs];</span><br><span class="line">		tb[ls]=tb[rs]=tb[x];</span><br><span class="line">		tb[x]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ans[ls]+=ta[x]*sb[ls];</span><br><span class="line">		ans[rs]+=ta[x]*sb[rs];</span><br><span class="line">	&#125;</span><br><span class="line">	ta[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bu</span><span class="params">(LL x,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">        ans[x]=a[l]*b[l];</span><br><span class="line">        sa[x]=a[l];</span><br><span class="line">		sb[x]=b[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bu</span>(ls,l,lm);</span><br><span class="line">	<span class="built_in">bu</span>(rs,rm,r);</span><br><span class="line">    <span class="built_in">pu</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">se</span><span class="params">(LL x,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t&lt;l||s&gt;r)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(s&lt;=l&amp;&amp;r&lt;=t)</span><br><span class="line">	&#123;</span><br><span class="line">		sb[x]=d*(r-l+<span class="number">1</span>);</span><br><span class="line">		ans[x]=d*sa[x];</span><br><span class="line">		tb[x]=d;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pd</span>(x,l,r);</span><br><span class="line">	<span class="built_in">se</span>(ls,l,lm);</span><br><span class="line">	<span class="built_in">se</span>(rs,rm,r);</span><br><span class="line">	<span class="built_in">pu</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(LL x,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t&lt;l||s&gt;r)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(s&lt;=l&amp;&amp;r&lt;=t)</span><br><span class="line">	&#123;</span><br><span class="line">		sa[x]+=d*(r-l+<span class="number">1</span>);</span><br><span class="line">		ans[x]+=d*sb[x];</span><br><span class="line">		ta[x]+=d;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pd</span>(x,l,r);</span><br><span class="line">	<span class="built_in">add</span>(ls,l,lm);</span><br><span class="line">	<span class="built_in">add</span>(rs,rm,r);</span><br><span class="line">	<span class="built_in">pu</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>)cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">	<span class="built_in">bu</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(q--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;op&gt;&gt;s&gt;&gt;t&gt;&gt;d;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="string">&quot;Set&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">se</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;ans[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h4 id="t6"><a href="https://www.luogu.com.cn/problem/CF600E">T6</a></h4>
<p>权值线段树 <span class="math inline">\(+\)</span> 线段树合并。</p>
<p>每个子树中的颜色，开一颗权值线段树，向上回溯时合并即可。</p>
<h4 id="t7"><a href="https://www.luogu.com.cn/problem/P1856">T7</a></h4>
<p>首先，需要离散化，而后处理时有两种思路：</p>
<div class="tabs" id="两种思路"><ul class="nav-tabs"><li class="tab"><a href="#两种思路-1">思路一</a></li><li class="tab"><a href="#两种思路-2">思路二</a></li></ul><div class="tab-content"><div class="tab-pane" id="两种思路-1"><p>用一棵线段树，所以有一点点思维难度。</p>
<p>从上向下扫描，每次遇到一条边，若为上边，则在线段树上此区间进行加操作，下边则在此区间进行减操作。与面积并时相似。这是横边。竖边则利用扫描线走过的距离乘横向距离即可。</p>
<p>可以参考<a href="https://www.luogu.com.cn/article/9cuyuf44">这篇题解</a>。</p></div><div class="tab-pane" id="两种思路-2"><p>思路一的思维难度在于，竖边的处理较为麻烦，那么我们就如法炮制，竖边也建一棵线段树处理。</p></div></div></div>
<h3 id="小结">小结</h3>
<p>其实线段树还有不少应用，限于篇幅只能列出一部分。</p>
<p>赛中一般不会出裸线段树，所以想到用线段树是一个重要环节。</p>
<p>剩余部分可以参见
OI-wiki，讲的很清晰。有时间或有需求也可以学习几种线段树变形（李超等）。</p>
<p>另，由于部分题目代码过于长或因为某题最好自己写代码以学习，所以我没有放。</p>
<h3 id="致谢">致谢</h3>
<p>我学校的信息学教练 zxc 以及不是我学校的一位教练
gtc，为此文提供了例题以及基础；</p>
<p>OI-wiki 线段树部分编写人员及 OI-wiki
建设者，为本文线段树合并部分提供了定义以及为扫描线提供动图讲解；</p>
<p>我之前的英语老师 Cally，为本博客风格提供建议；</p>
<p>同学 lqs、whl，为我改代码（T5，lqs），讲解 T4（whl）；</p>
<p>hexo、github以及 next，为本博客提供支持；</p>
<p>同学 lyh，帮我调弄 hexo；</p>
<p>洛谷，提供题目、上传图片、教会我 <span class="math inline">\(\LaTeX\)</span>；</p>
<p><span class="math inline">\(mathjax\)</span>，对本文提供 <span class="math inline">\(\LaTeX\)</span> 支持。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
</search>
