<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>单调队列 &amp; 斜率优化 DP 学习笔记</title>
    <url>/2024/05/11/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96-%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96DP/</url>
    <content><![CDATA[<h4 id="单调队列优化-dp">单调队列优化 DP</h4>
<h5 id="单调队列">单调队列</h5>
<p>注意，其与优先队列不是同一种数据结构。（其实也不是严格的队列）</p>
<p><a href="https://www.luogu.com.cn/problem/P1886">其模板题</a>。</p>
<p>每当一个新的数加入，当队尾大于等于/小于等于（取决于每一道题目）这个数时，弹出队尾（因此这不是严格的队列）并继续比较直到队尾不满足其大于等于/小于等于这个数或队列空。然后将这个数加入队尾。</p>
<p>还有一个操作：当队头不优时，弹出队头。</p>
<h5 id="似乎无法优化-dp">似乎无法优化 DP？</h5>
<p><a href="https://www.luogu.com.cn/problem/CF372C">例题</a></p>
<p>状态设计可以想到是当放第 <span class="math inline">\(i\)</span>
个烟花的时候你在 <span class="math inline">\(j\)</span>
位置能获得的最大开心度。</p>
<p>转移方程依据题意，是 <span class="math display">\[
f_{i,j}=\max\lbrace f_{i-1,k}+b_i-|a_i-j|\rbrace
\]</span> <details class="note info no-icon"><summary><p>此处 <span class="math inline">\(k\)</span> 范围</p>
</summary>
<p><span class="math display">\[
j-(t_i-t_{i-1})\times d\le k \le j+(t_i-t_{i-1})\times d
\]</span></p>

</details></p>
<p>然而会超时，考虑优化。</p>
<p>但是，这坨式子很明显无法单调队列优化，其他优化似乎也不行。</p>
<h5 id="一个想法">一个想法</h5>
<p>暴力是三层循环，第一层 <span class="math inline">\(i\)</span>，第二层
<span class="math inline">\(j\)</span>，第三层 <span class="math inline">\(k\)</span>（因为 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 决定 <span class="math inline">\(k\)</span> 的范围）。</p>
<p>转移在 <span class="math inline">\(k\)</span> 层进行。</p>
<p>此时 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 已经固定，所以： <span class="math display">\[
f_{i,j}=\max\lbrace f_{i-1,k}\rbrace+b_i-|a_i-j|
\]</span> 既然 <span class="math inline">\(+b_i-|a_i-j|\)</span>
影响单调队列，我们就提出去！</p>
<p>于是时间复杂度降到 <span class="math inline">\(O(nm)\)</span>。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code from OI-wiki
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">150000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxm = <span class="number">300</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll f[<span class="number">2</span>][maxn];</span><br><span class="line">ll a[maxm], b[maxm], t[maxm];</span><br><span class="line"><span class="type">int</span> n, m, d;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> que[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fl = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">207</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">  <span class="built_in">memset</span>(que, <span class="number">0</span>, <span class="built_in">sizeof</span>(que));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">  fl = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;  <span class="comment">// 在这里使用了单调队列的优化，推式子详见上面</span></span><br><span class="line">      <span class="keyword">for</span> (; k &lt;= <span class="built_in">min</span>(<span class="number">1ll</span> * n, j + d * (t[i] - t[i - <span class="number">1</span>])); k++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; f[fl ^ <span class="number">1</span>][que[r]] &lt;= f[fl ^ <span class="number">1</span>][k]) r--;</span><br><span class="line">        que[++r] = k;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (l &lt;= r &amp;&amp; que[l] &lt; <span class="built_in">max</span>(<span class="number">1ll</span>, j - d * (t[i] - t[i - <span class="number">1</span>]))) l++;</span><br><span class="line">      f[fl][j] = f[fl ^ <span class="number">1</span>][que[l]] - <span class="built_in">abs</span>(a[i] - j) + b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fl ^= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; t[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// then dp</span></span><br><span class="line">  <span class="built_in">dp</span>();</span><br><span class="line">  ll ans = <span class="number">-1e18</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = <span class="built_in">max</span>(ans, f[fl ^ <span class="number">1</span>][i]);</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h5 id="多重背包的单调队列优化">多重背包的单调队列优化</h5>
<p>不会打这种 <span class="math inline">\(\LaTeX\)</span>，见 <a href="https://oi-wiki.org/dp/opt/monotonous-queue-stack/#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85">link,
thanks to OI-wiki again</a>。</p>
<h4 id="斜率优化参考了罗勇军郭卫斌的算法竞赛">斜率优化！（参考了罗勇军、郭卫斌的《算法竞赛》）</h4>
<p>有一种 DP 转移方程： <span class="math display">\[
dp_i=\min\{dp_j-a_id_j\}(0\le j&lt;i,d_j\le d_{j+1},a_i\le a_{i+1})
\]</span> 朴素的去 DP，<span class="math inline">\(O(n^2)\)</span>。</p>
<h5 id="转换">转换</h5>
<p>把 <span class="math inline">\(i\)</span> 看作不变的常量。</p>
<p>把除了 <span class="math inline">\(dp_i\)</span> 以外的所有与 <span class="math inline">\(i\)</span> 有关的项看作常量。</p>
<p>把 <span class="math inline">\(j\)</span> 看作变量。</p>
<p>要求 <span class="math inline">\(j\)</span> 变化时 <span class="math inline">\(dp_i\)</span> 的最优值。</p>
<p>把 <span class="math inline">\(\min\)</span> 去掉，就变成了： <span class="math display">\[
dp_j=a_id_j+dp_i
\]</span> 为了让它看着像一次函数（才能求斜率），设 <span class="math inline">\(y=dp_j,x=d_j,k=a_i,b=dp_i\)</span>。</p>
<p>原式变为 <span class="math inline">\(y=kx+b\)</span>。</p>
<p>斜率优化需要满足几个条件：</p>
<ol type="1">
<li><p><span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 与 <span class="math inline">\(j\)</span> 有关，且只有 <span class="math inline">\(y\)</span> 中包含 <span class="math inline">\(dp_j\)</span>。于是 <span class="math inline">\((x,y)\)</span> 这个点就是一种决策。</p></li>
<li><p>斜率 <span class="math inline">\(k\)</span>、截距 <span class="math inline">\(b\)</span> 与 <span class="math inline">\(i\)</span> 有关，并且只有 <span class="math inline">\(b\)</span> 中含 <span class="math inline">\(dp_i\)</span>，其中最小的 <span class="math inline">\(b\)</span> 包含最小的 <span class="math inline">\(dp_i\)</span>，也就是转移方程的解。</p></li>
</ol>
<p><span class="math inline">\((x_1,y_1)\)</span> 和 <span class="math inline">\((x_2,y_2)\)</span> 这两个点组成的直线的斜率为
<span class="math inline">\((y_2-y_1)/(x_2-x_1)\)</span>，我们会发现这个斜率<strong>只与
<span class="math inline">\(j\)</span>
有关</strong>，于是可以用单调队列！</p>
<div class="note warning"><p>还有一点，<span class="math inline">\(x\)</span> 与 <span class="math inline">\(k\)</span> 要单调增加。</p>
<p>具体来说：<span class="math inline">\(x\)</span> 随 <span class="math inline">\(j\)</span> 递增而递增，<span class="math inline">\(k\)</span> 随 <span class="math inline">\(i\)</span> 递增而递增。</p>
</div>
<h5 id="求某个-dp_i">求某个 <span class="math inline">\(dp_i\)</span></h5>
<p>我们要求最优点，设它为 <span class="math inline">\(v\)</span>。</p>
<p>利用“下凸壳”。</p>
<p>如果这次转移的各个点（决策）是这样的：</p>
<p><img src="https://cppomstar.github.io/images/xielvDPno1.png"></p>
<p>上凸壳就是 <span class="math inline">\(2,3,4\)</span>。</p>
<p>我们可以发现：经过上凸壳<strong>中间那个点</strong>（即 <span class="math inline">\(3\)</span>）的直线的截距（<span class="math inline">\(b\)</span>）一定大于（《算法竞赛》中此处为“小于”，应为笔误）<span class="math inline">\(2\)</span> 和 <span class="math inline">\(4\)</span> 的直线的截距，于是 <span class="math inline">\(3\)</span>
一定不是最终的最优的点，去掉（绿色代表删掉了）：</p>
<p><img src="https://cppomstar.github.io/images/xielvDPno2.png"></p>
<p>剩的点都满足下凸壳关系（<span class="math inline">\(12\)</span>
的斜率小于 <span class="math inline">\(24\)</span> 的斜率）。</p>
<p>假设在这里面 <span class="math inline">\(12\)</span> 的斜率小于 <span class="math inline">\(k\)</span>，<span class="math inline">\(34\)</span> 的斜率大于 <span class="math inline">\(k\)</span>，那么最优点就是 <span class="math inline">\(2\)</span>（如下图，蓝色直线即为斜率为 <span class="math inline">\(k\)</span> 的直线）。</p>
<p><img src="https://cppomstar.github.io/images/xielvDPno3.png"></p>
<p>然后我们发现这部分用单调队列做非常容易。</p>
<h6 id="入队">入队</h6>
<p>我们现在要处理一个斜率：<span class="math inline">\((y_2-y_1)/(x_2-x_1)\)</span>。</p>
<p>斜率要<strong>单调上升</strong>，因为是下凸壳。</p>
<p>如果准备进队了发现斜率不单调上升，就把前面弹走。</p>
<p>每次进队后就大致像下图的结构（By OI Painter）：</p>
<p><img src="https://cppomstar.github.io/images/xielvDPno4.png"></p>
<h6 id="出队">出队</h6>
<p>注意，这说的是前面提到的“当队头不优时，弹出队头”。</p>
<p>设队头的两个点分别是 <span class="math inline">\(v_1\)</span> 和
<span class="math inline">\(v_2\)</span>。</p>
<p>如果 <span class="math inline">\(v_1v_2\)</span>
这条线段的斜率小于<strong>等于</strong>（我认为此处应该有等于，因为我们的条件是“左边的斜率小于
<span class="math inline">\(k\)</span>，右边的的斜率大于 <span class="math inline">\(k\)</span>”） <span class="math inline">\(k\)</span>，就可以把 <span class="math inline">\(v_1\)</span> 弹出去了（如上，不可能最优）。</p>
<p>然后一直弹，弹到 <span class="math inline">\(v_1v_2\)</span>
这条线段的斜率大于 <span class="math inline">\(k\)</span>，此时队头就是这个 <span class="math inline">\(dp_i\)</span> 的最优点。</p>
<h5 id="快速地求所有的-dp_i">（快速地）求所有的 <span class="math inline">\(dp_i\)</span></h5>
<p>然而我们会发现一个显著的问题：</p>
<details class="note danger"><summary><p>问题</p>
</summary>
<p>求一个 <span class="math inline">\(dp_i\)</span> 是 <span class="math inline">\(O(n)\)</span> 的。</p>
<p>求所有的是 <span class="math inline">\(O(n^2)\)</span> 的。</p>
<p>那这和暴力似乎没有区别。</p>

</details>
<p>我们来列一下各个 <span class="math inline">\(dp_i\)</span>
要处理的决策点：</p>
<p>举个例子，有两个数，<span class="math inline">\(j\)</span> 和 <span class="math inline">\(o\)</span>。</p>
<p>不妨设 <span class="math inline">\(j&lt;o\)</span>。</p>
<p><span class="math inline">\(dp_j\)</span>
要处理的之前的决策点是：</p>
<p><span class="math display">\[
{v_0,v_1,\dots,s_j}
\]</span></p>
<p><span class="math inline">\(dp_o\)</span>
要处理的之前的决策点是：</p>
<p><span class="math display">\[
{v_0,v_1,\dots,s_j,\dots,s_o}
\]</span></p>
<p>前面的 <span class="math inline">\({v_0,v_1,\dots,s_j}\)</span>
是重复的，可以避免这些重复的扫描。</p>
<details class="note info"><summary><p>方法</p>
</summary>
<p>《算法竞赛》上我觉得讲麻烦了，我讲一下我的想法：</p>
<p>我们前文保证过“<span class="math inline">\(x\)</span> 与 <span class="math inline">\(k\)</span> 单调增加”，于是 <span class="math inline">\(k_o\)</span> 的斜率一定大于 <span class="math inline">\(k_j\)</span> 的。</p>
<p>于是我们只用一个单调队列从头到尾处理即可，每次处理完剩下的数据后一个位置还能用。</p>
<p>时间复杂度骤降至 <span class="math inline">\(O(n)\)</span>。</p>

</details>
<p>核心代码如下：</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        main code
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(h&lt;t&amp;&amp;slope<span class="comment">/*斜率函数，但这个词一般表示“斜坡”*/</span>(q[h],q[h+<span class="number">1</span>])&lt;k)h++;</span><br><span class="line">    dp[i]=<span class="comment">/*状态转移方程*/</span>;</span><br><span class="line">    <span class="keyword">while</span>(h&lt;t&amp;&amp;<span class="built_in">slope</span>(i,q[t<span class="number">-1</span>])&lt;<span class="built_in">slope</span>(q[t<span class="number">-1</span>],q[t]))t--;</span><br><span class="line">    q[++t]=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p>然而我想说点有关代码的事：</p>
<details class="note success"><summary><p>既然写到了代码</p>
</summary>
<p>首先要有一个良好的代码习惯，比如记住上面那个代码，当作模板；</p>
<p>第二是我个人倡导的把大括号写开，即：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="comment">/*...*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*do sth*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而不是用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="comment">/*...*/</span>)&#123;</span><br><span class="line">    <span class="comment">/*do sth*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者其他难以找到这个大括号对应的前面的或后面的在哪、难以调试的代码风格。</p>
<p>这样可以更好地调试，也可以有更好的心态（这是作为 OIer
很重要的一点）。</p>
<p>第三就是如果遇到毒瘤出题人卡精度，使用 <code>slope</code>
会有精度误差时，可以像我的同学 ly 那样写一个 <code>slope_fz</code> 和
<code>slope_fm</code>
函数，比较时就交叉相乘（不会有不等号反向因为在斜率优化里斜率都<strong>必须</strong>是正的）。</p>

</details>
<h5 id="例题"><a href="https://www.acwing.com/problem/content/description/4841/">例题</a></h5>
<p>设 <span class="math inline">\(f_i\)</span> 表示输出前 <span class="math inline">\(i\)</span> 个单词的最少费用，那么根据题意，我们设
<span class="math inline">\(s_i\)</span> 表示前 <span class="math inline">\(i\)</span> 个单词的费用之和。</p>
<p>转移方程就是：</p>
<p><span class="math display">\[
dp_i=\min\{dp_j+(s_i-s_j)^2+M\}
\]</span></p>
<p>其中 <span class="math inline">\(1\le j&lt;i\)</span>。</p>
<p>中间过程大致如下：</p>
<p>展开、移项（对照 <span class="math inline">\(y=kx+b\)</span>
的格式和要求），得：</p>
<p><span class="math display">\[
dp_j+{s_j}^2=2s_is_j+dp_i-{s_i}^2-M
\]</span></p>
<p>那么，<span class="math inline">\(y\)</span> 是 <span class="math inline">\(dp_j+{s_j}^2\)</span>，<span class="math inline">\(x\)</span> 是 <span class="math inline">\(2s_j\)</span>，<span class="math inline">\(k\)</span> 是 <span class="math inline">\(s_i\)</span>，<span class="math inline">\(b\)</span> 是 <span class="math inline">\(dp_i-{s_i}^2-M\)</span>，而且符合条件。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code by ly（I solved the bugs）
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll n,m,q[N],l,r;</span><br><span class="line">ll a[N],dp[N];</span><br><span class="line"><span class="function">ll <span class="title">get_x</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>*a[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">get_y</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dp[x]+a[x]*a[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">slope_fz</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">get_y</span>(x)-<span class="built_in">get_y</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">slope_fm</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">get_x</span>(x)-<span class="built_in">get_x</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">	&#123;</span><br><span class="line">		l=<span class="number">0</span>;</span><br><span class="line">		r=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">		<span class="built_in">memset</span>(q,<span class="number">0</span>,<span class="built_in">sizeof</span>(q));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">			a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;r&amp;&amp;<span class="built_in">slope_fz</span>(q[l+<span class="number">1</span>],q[l])&lt;=(__int128)a[i]*<span class="built_in">slope_fm</span>(q[l+<span class="number">1</span>],q[l])) l++;</span><br><span class="line">			dp[i]=dp[q[l]]+m+(a[i]-a[q[l]])*(a[i]-a[q[l]]);</span><br><span class="line">			<span class="keyword">while</span>(l&lt;r&amp;&amp;(__int128)<span class="built_in">slope_fz</span>(i,q[r])*<span class="built_in">slope_fm</span>(q[r],q[r<span class="number">-1</span>])&lt;=(__int128)<span class="built_in">slope_fz</span>(q[r],q[r<span class="number">-1</span>])*<span class="built_in">slope_fm</span>(i,q[r])) r--;</span><br><span class="line">			q[++r]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp[n]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

    </div>
</div>
<div class="note success"><p>斜率优化的代码特别容易踩坑。</p>
<p>具体我目前知道的有：</p>
<ol type="1">
<li><p>数据卡精度（解决方案：像上面的代码那样写一个分子函数一个分母函数比较时交叉相乘）</p></li>
<li><p>单调队列写挂（即我解决的 bug）（解决方案：写成上文代码那样的
<code>l&lt;r</code> 单调队列，或者这么写，见下：）</p></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*初始化*/</span></span><br><span class="line">l=<span class="number">1</span>;</span><br><span class="line">r=<span class="number">0</span>;</span><br><span class="line">q[++l]=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*用的时候*/</span></span><br><span class="line">l&lt;=r</span><br></pre></td></tr></table></figure>
</div>
<h4 id="小结">小结</h4>
<p>斜率优化可以算是比较高级的 DP 优化了。</p>
<p>有些别的优化时间复杂度比斜率优化劣，比如笔者 2024.5.19
写的一道题，四边形不等式 <span class="math inline">\(O(n\log
n)\)</span>，而斜率优化 <span class="math inline">\(O(n)\)</span>。</p>
<p>也可以找些习题进行练习，如 <a href="https://www.luogu.com.cn/problem/P5785" class="uri">https://www.luogu.com.cn/problem/P5785</a> 等。</p>
<p>另，由于本博客成文时间仓促，可能会有些错误，欢迎指出。</p>
<h4 id="致谢">致谢</h4>
<p>我学校的信息学教练 zxc，为此文提供了基础；</p>
<p>OI-wiki 斜率优化、单调队列优化部分编写人员及 OI-wiki
建设者，为本文提供代码及部分参考；</p>
<p>同学 whl，专门给我讲了一次斜率优化；</p>
<p>同学 ly，提供例题代码（虽然我改了一点）、经典错误和其解决方案；</p>
<p>OI Painter 开发者 EternalAlexander，提供一张图片的绘画支持；</p>
<p>tldraw 开发者，提供三张图片的绘画支持；</p>
<p>AcWing 站长 yxc，提供例题；</p>
<p>罗勇军、郭卫斌及其他《算法竞赛》编写、贡献者，为斜率优化部分提供参考。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>DP</category>
        <category>DP 优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>学习笔记</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树学习笔记</title>
    <url>/2024/04/25/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>请注意，本文默认大家学过单改区查的基础线段树（包括动态开点），若未学，请移步
<a href="https://oi-wiki.org/ds/seg/">OI-wiki</a>，例题可以使用树状数组的题目。</p>
<h3 id="区间修改懒标记lazy-tag">区间修改：懒标记（lazy-tag）</h3>
<details class="note info no-icon"><summary><p><a href="https://www.luogu.com.cn/problem/P3372">【模板】线段树
1</a></p>
</summary>
<p>题目描述</p>
<p>已知一个数列，你需要进行下面两种操作：</p>
<ol type="1">
<li>将某区间每一个数加上 <span class="math inline">\(k\)</span>。</li>
<li>求出某区间每一个数的和。</li>
</ol>
<p>输入格式</p>
<p>第一行包含两个整数 <span class="math inline">\(n,
m\)</span>，分别表示该数列数字的个数和操作的总个数。</p>
<p>第二行包含 <span class="math inline">\(n\)</span>
个用空格分隔的整数，其中第 <span class="math inline">\(i\)</span>
个数字表示数列第 <span class="math inline">\(i\)</span> 项的初始值。</p>
<p>接下来 <span class="math inline">\(m\)</span> 行每行包含 <span class="math inline">\(3\)</span> 或 <span class="math inline">\(4\)</span> 个整数，表示一个操作，具体如下：</p>
<ol type="1">
<li><code>1 x y k</code>：将区间 <span class="math inline">\([x,
y]\)</span> 内每个数加上 <span class="math inline">\(k\)</span>。</li>
<li><code>2 x y</code>：输出区间 <span class="math inline">\([x,
y]\)</span> 内每个数的和。</li>
</ol>
<p>输出格式</p>
<p>输出包含若干行整数，即为所有操作 2 的结果。</p>
<p>样例输入 #1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 5 4 2 3</span><br><span class="line">2 2 4</span><br><span class="line">1 2 3 2</span><br><span class="line">2 3 4</span><br><span class="line">1 1 5 1</span><br><span class="line">2 1 4</span><br></pre></td></tr></table></figure>
<p>样例输出 #1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br><span class="line">8</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<p>提示</p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据：<span class="math inline">\(1 \le n, m \le {10}^5\)</span>。</p>

</details>
<p>很明显，如果用暴力进行区间修改，不能通过。</p>
<p>那么引入 lazy-tag。</p>
<p>首先，先介绍 lazy-tag 的概念：</p>
<p>对于每个有 lazy-tag
的节点，在只有需要用到自己的子节点时才会把修改的命令（lazy-tag）交给子节点。</p>
<p>lazy-tag 用一个叫做 <code>push_down</code> 的操作下放修改操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">p_d_</span><span class="params">(<span class="type">long</span> <span class="type">long</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> L=u&lt;&lt;<span class="number">1</span>,R=u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">	t[L].sum+=t[u].y*(t[L].r-t[L].l+<span class="number">1</span>);<span class="comment">//处理左子树总和</span></span><br><span class="line">	t[R].sum+=t[u].y*(t[R].r-t[R].l+<span class="number">1</span>);<span class="comment">//右子树</span></span><br><span class="line">	t[L].y+=t[u].y;<span class="comment">//标记下放</span></span><br><span class="line">	t[R].y+=t[u].y;<span class="comment">//同上</span></span><br><span class="line">	t[u].y=<span class="number">0</span>;<span class="comment">//清零，代表下放结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>y</code> 就是 lazy-tag。</p>
<p>第二，<code>up_date</code> 函数在符合
<code>t[u].l&gt;=l&amp;&amp;t[u].r&lt;=r</code> 时，将 lazy-tag
加上此次加操作的值，并增加此区间总和。</p>
<p>若不符合，则进行 <code>push_down</code>
操作，为递归左右子树铺垫。</p>
<p>第三，<code>query</code> 函数在
<code>t[u].l&gt;=l&amp;&amp;t[u].r&lt;=r</code> 不成立时，也需进行
<code>push_down</code> 操作，原因同上。</p>
<p>显然，此时复杂度为 <span class="math inline">\(O(mlogn)\)</span></p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,m,x,y;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> k;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[<span class="number">500010</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> l,r,sum,y;</span><br><span class="line">&#125;t[<span class="number">500010</span>&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p_u_</span><span class="params">(<span class="type">long</span> <span class="type">long</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].sum=t[u&lt;&lt;<span class="number">1</span>].sum+t[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p_d_</span><span class="params">(<span class="type">long</span> <span class="type">long</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> L=u&lt;&lt;<span class="number">1</span>,R=u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">	t[L].sum+=t[u].y*(t[L].r-t[L].l+<span class="number">1</span>);</span><br><span class="line">	t[R].sum+=t[u].y*(t[R].r-t[R].l+<span class="number">1</span>);</span><br><span class="line">	t[L].y+=t[u].y;</span><br><span class="line">	t[R].y+=t[u].y;</span><br><span class="line">	t[u].y=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">b_</span><span class="params">(<span class="type">long</span> <span class="type">long</span> u,<span class="type">long</span> <span class="type">long</span> l,<span class="type">long</span> <span class="type">long</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].l=l,t[u].r=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].sum=a[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">b_</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">	<span class="built_in">b_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">p_u_</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">u_d_</span><span class="params">(<span class="type">long</span> <span class="type">long</span> u,<span class="type">long</span> <span class="type">long</span> l,<span class="type">long</span> <span class="type">long</span> r,<span class="type">long</span> <span class="type">long</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[u].l&gt;=l&amp;&amp;t[u].r&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].sum+=c*(t[u].r-t[u].l+<span class="number">1</span>);</span><br><span class="line">		t[u].y+=c;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">p_d_</span>(u);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> mid=(t[u].l+t[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)<span class="built_in">u_d_</span>(u&lt;&lt;<span class="number">1</span>,x,y,c);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) <span class="built_in">u_d_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y,c);</span><br><span class="line">	<span class="built_in">p_u_</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">q_</span><span class="params">(<span class="type">long</span> <span class="type">long</span> u,<span class="type">long</span> <span class="type">long</span> l,<span class="type">long</span> <span class="type">long</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=t[u].l&amp;&amp;r&gt;=t[u].r)<span class="keyword">return</span> t[u].sum;</span><br><span class="line">	<span class="built_in">p_d_</span>(u);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> mid=(t[u].l+t[u].r)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)ans+=<span class="built_in">q_</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)ans+=<span class="built_in">q_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">b_</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;k;</span><br><span class="line">		<span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">			<span class="built_in">u_d_</span>(<span class="number">1</span>,x,y,k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">			cout&lt;&lt;<span class="built_in">q_</span>(<span class="number">1</span>,x,y)&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h3 id="权值线段树">权值线段树</h3>
<p>普通的线段树，记录的是数组中当前区间的各种信息。</p>
<p>权值线段树，则记录的是每种数据出现的次数。</p>
<p>如：数组为 <code>1 1 4 5 1 4</code></p>
<p>则其出现次数为（从 <span class="math inline">\(0\)</span>
开始）<code>0 3 0 0 2 1</code>。</p>
<h3 id="线段树合并">线段树合并</h3>
<p>前置知识：权值线段树（一般线段树合并合并的是权值线段树）。</p>
<blockquote>
<p>线段树合并是指建立一棵新的线段树，这棵线段树的每个节点都是两棵原线段树对应节点合并后的结果。它常常被用于维护树上或是图上的信息。——OI
wiki</p>
</blockquote>
<p>如果每次合并都新开一棵满树，时间、空间都无法接受。</p>
<p>那么，就需要本文开头提到的前置知识动态开点。</p>
<p>设需要合并的两棵树分别叫 <span class="math inline">\(T1\)</span> 和
<span class="math inline">\(T2\)</span>。</p>
<p>从上往下（即从 <span class="math inline">\(1\)</span>
号节点开始递归向下），对于每个节点，若 <span class="math inline">\(T1\)</span> 上无此节点，就只加入 <span class="math inline">\(T2\)</span> 上的此节点。反之亦然。</p>
<p>如果都有此节点，若是叶子节点，直接合并所有信息。</p>
<p>若否，通过子节点的返回（返回左儿子、右儿子）更新。</p>
<p>OI-wiki
上对其时间复杂度的证明不严谨，读者可以在写的时候自己证其时间复杂度。</p>
<h3 id="扫描线">扫描线</h3>
<p>下面这张动图，诠释了这种算法在处理面积并上的的大致思路：（感谢
OI-wiki，面积并处理部分也请参见 OI-wiki）</p>
<p><img src="https://cppomstar.github.io//images/scanning.svg"></p>
<p>本博客则讲述其解决周长并上的解法，详见<a href="https://cppomstar.github.io/2024/04/25/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#t7">T7</a>。</p>
<h3 id="例题">例题</h3>
<h4 id="t1">T1</h4>
<p><img src="https://cppomstar.github.io//images/segtreeT1.png"></p>
<p>首先的思路是暴力（二维前缀和），然而会时间和空间超限。</p>
<p>优化：因为“星星按y坐标增序给出，y坐标相同的按x坐标增序给出”，所以只需查找从
<span class="math inline">\(0\)</span>
高度到此高度范围内共有多少颗星星（因为保证 <span class="math inline">\(y\)</span> 增序了），求和即可。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> esp 1e-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 999999999999999999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b,g) for(LL i=a;i&lt;=b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rem(i,a,b,g) for(LL i=a;i&gt;=b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> repn(i,a,b,g) for(LL i=a;i&lt;b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> remn(i,a,b,g) for(LL i=a;i&gt;b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;LL,LL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mkp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i128 __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(i128 &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i128 f=<span class="number">1</span>;</span><br><span class="line">	x=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writing</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">10</span>)<span class="built_in">writing</span>(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">		x=-x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">writing</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">LL n,x[<span class="number">1000010</span>],y[<span class="number">1000010</span>];</span><br><span class="line">LL k;</span><br><span class="line">LL a[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">	LL l,r,sum,y;</span><br><span class="line">&#125;t[<span class="number">1000010</span>&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p_u_</span><span class="params">(LL u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].sum=t[u&lt;&lt;<span class="number">1</span>].sum+t[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p_d_</span><span class="params">(LL u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL L=u&lt;&lt;<span class="number">1</span>,R=u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">	t[L].sum+=t[u].y*(t[L].r-t[L].l+<span class="number">1</span>);</span><br><span class="line">	t[R].sum+=t[u].y*(t[R].r-t[R].l+<span class="number">1</span>);</span><br><span class="line">	t[L].y+=t[u].y;</span><br><span class="line">	t[R].y+=t[u].y;</span><br><span class="line">	t[u].y=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">b_</span><span class="params">(LL u,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].l=l;</span><br><span class="line">	t[u].r=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LL mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">b_</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">	<span class="built_in">b_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">p_u_</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">u_d_</span><span class="params">(LL u,LL l,LL r,LL c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[u].l&gt;=l&amp;&amp;t[u].r&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].sum+=c*(t[u].r-t[u].l+<span class="number">1</span>);</span><br><span class="line">		t[u].y+=c;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">p_d_</span>(u);</span><br><span class="line">	LL mid=(t[u].l+t[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)<span class="built_in">u_d_</span>(u&lt;&lt;<span class="number">1</span>,l,r,c);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) <span class="built_in">u_d_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,c);</span><br><span class="line">	<span class="built_in">p_u_</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">q_</span><span class="params">(LL u,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=t[u].l&amp;&amp;r&gt;=t[u].r)<span class="keyword">return</span> t[u].sum;</span><br><span class="line">	<span class="built_in">p_d_</span>(u);</span><br><span class="line">	LL mid=(t[u].l+t[u].r)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)ans+=<span class="built_in">q_</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)ans+=<span class="built_in">q_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">LL sum[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">b_</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">320000</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LL u=x[i]+<span class="number">1</span>;</span><br><span class="line">		LL v=<span class="built_in">q_</span>(<span class="number">1</span>,<span class="number">1</span>,u);</span><br><span class="line">		<span class="built_in">u_d_</span>(<span class="number">1</span>,u,u,<span class="number">1</span>);</span><br><span class="line">		sum[v+<span class="number">1</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;sum[i]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h4 id="t2"><a href="https://www.luogu.com.cn/problem/P5057">T2</a></h4>
<p>很明显，因为是“区查单改”且是较为特殊的异或，我们需要把“异或次数”作为
lazy-tag。</p>
<p>同时因为只有 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(0\)</span>，所以 lazy-tag 每次异或（即 <span class="math inline">\(+1\bmod 2\)</span>）即可。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> esp 1e-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 999999999999999999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b,g) for(LL i=a;i&lt;=b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rem(i,a,b,g) for(LL i=a;i&gt;=b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> repn(i,a,b,g) for(LL i=a;i&lt;b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> remn(i,a,b,g) for(LL i=a;i&gt;b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;LL,LL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mkp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i128 LL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(i128 &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i128 f=<span class="number">1</span>;</span><br><span class="line">	x=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writing</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">10</span>)<span class="built_in">writing</span>(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">		x=-x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">writing</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">LL n,m,x,y,k,a[<span class="number">100010</span>],tt[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">	LL l,r,sum,y;</span><br><span class="line">&#125;t[<span class="number">100010</span>&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p_u_</span><span class="params">(LL u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].sum=t[u&lt;&lt;<span class="number">1</span>].sum+t[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p_d_</span><span class="params">(LL u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL L=u&lt;&lt;<span class="number">1</span>,R=u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">	t[L].sum=t[L].r-t[L].l+<span class="number">1</span>-t[L].sum;</span><br><span class="line">	t[R].sum=t[R].r-t[R].l+<span class="number">1</span>-t[R].sum;</span><br><span class="line">	t[L].y^=<span class="number">1</span>;</span><br><span class="line">	t[R].y^=<span class="number">1</span>;</span><br><span class="line">	t[u].y=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">b_</span><span class="params">(LL u,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].l=l,t[u].r=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].sum=tt[l<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LL mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">b_</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">	<span class="built_in">b_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">p_u_</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">u_d_</span><span class="params">(LL u,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[u].l&gt;=l&amp;&amp;t[u].r&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].sum=t[u].r-t[u].l+<span class="number">1</span>-t[u].sum;</span><br><span class="line">		t[u].y^=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t[u].y)<span class="built_in">p_d_</span>(u);</span><br><span class="line">	LL mid=(t[u].l+t[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)<span class="built_in">u_d_</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)<span class="built_in">u_d_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="built_in">p_u_</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">q_</span><span class="params">(LL u,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=t[u].l&amp;&amp;r&gt;=t[u].r)<span class="keyword">return</span> t[u].sum;</span><br><span class="line">	<span class="keyword">if</span>(t[u].y)<span class="built_in">p_d_</span>(u);</span><br><span class="line">	LL mid=(t[u].l+t[u].r)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)ans+=<span class="built_in">q_</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)ans+=<span class="built_in">q_</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="built_in">b_</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(k);</span><br><span class="line">		<span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">read</span>(x);</span><br><span class="line">			<span class="built_in">read</span>(y);</span><br><span class="line">			<span class="built_in">u_d_</span>(<span class="number">1</span>,x,y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">read</span>(x);</span><br><span class="line">			y=x;</span><br><span class="line">			<span class="built_in">write</span>(<span class="built_in">q_</span>(<span class="number">1</span>,x,y));</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h4 id="t3"><a href="https://www.luogu.com.cn/problem/P4145">T3</a></h4>
<p>当然，“开方”操作的懒标记以及修改都很难做。</p>
<p>然而，我们发现：<span class="math inline">\(\Bigg \lfloor
\sqrt{\sqrt{\sqrt{\sqrt{\sqrt{\sqrt 10^{12}}}}}} \Bigg
\rfloor=1\)</span></p>
<p>所以就这样操作即可：不是全 <span class="math inline">\(0\)</span>
或全 <span class="math inline">\(1\)</span>，暴力；是，不管。</p>
<h4 id="t4"><a href="https://www.luogu.com.cn/problem/P3373">T4</a></h4>
<p>我们需要两个 lazy-tag，一个是乘的，一个是加的。</p>
<p>优先级是乘 <span class="math inline">\(&gt;\)</span>
加，因为加完再乘，加的那部分也要被乘，反之不然。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,p,opt,x,y,k;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">xds</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> l,r,sum,m,a;</span><br><span class="line">&#125;t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pu</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].sum=(t[u&lt;&lt;<span class="number">1</span>].sum+t[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> l=u&lt;&lt;<span class="number">1</span>,r=l|<span class="number">1</span>;</span><br><span class="line">	t[l].sum=(<span class="number">1ll</span>*t[l].sum*t[u].m+<span class="number">1ll</span>*(t[l].r-t[l].l+<span class="number">1</span>)*t[u].a)%p;</span><br><span class="line">	t[r].sum=(<span class="number">1ll</span>*t[r].sum*t[u].m+<span class="number">1ll</span>*(t[r].r-t[r].l+<span class="number">1</span>)*t[u].a)%p;</span><br><span class="line">	t[l].m=<span class="number">1ll</span>*t[l].m*t[u].m%p;</span><br><span class="line">	t[r].m=<span class="number">1ll</span>*t[r].m*t[u].m%p;</span><br><span class="line">	t[l].a=(<span class="number">1ll</span>*t[l].a*t[u].m+t[u].a)%p;</span><br><span class="line">	t[r].a=(<span class="number">1ll</span>*t[r].a*t[u].m+t[u].a)%p;</span><br><span class="line">	t[u].m=<span class="number">1</span>;</span><br><span class="line">	t[u].a=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">b</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].l=l;</span><br><span class="line">	t[u].r=r;</span><br><span class="line">	t[u].m=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].sum=a[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> z=t[u].l+t[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">b</span>(u&lt;&lt;<span class="number">1</span>,l,z);</span><br><span class="line">	<span class="built_in">b</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,z+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">pu</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mu</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[u].l&gt;=l&amp;&amp;t[u].r&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].sum=<span class="number">1ll</span>*t[u].sum*k%p;</span><br><span class="line">		t[u].m=<span class="number">1ll</span>*t[u].m*k%p;</span><br><span class="line">		t[u].a=<span class="number">1ll</span>*t[u].a*k%p;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t[u].m!=<span class="number">1</span>||t[u].a)<span class="built_in">pd</span>(u);</span><br><span class="line">	<span class="type">int</span> z=t[u].l+t[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=z)<span class="built_in">mu</span>(u&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;z)<span class="built_in">mu</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">	<span class="built_in">pu</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">au</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[u].l&gt;=l&amp;&amp;t[u].r&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].sum=(t[u].sum+<span class="number">1ll</span>*k*(t[u].r-t[u].l+<span class="number">1</span>))%p;</span><br><span class="line">		t[u].a=(t[u].a+k)%p;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t[u].m!=<span class="number">1</span>||t[u].a)<span class="built_in">pd</span>(u);</span><br><span class="line">	<span class="type">int</span> z=t[u].l+t[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=z)<span class="built_in">au</span>(u&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;z)<span class="built_in">au</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">	<span class="built_in">pu</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">q</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[u].l&gt;=l&amp;&amp;t[u].r&lt;=r)<span class="keyword">return</span> t[u].sum;</span><br><span class="line">	<span class="keyword">if</span>(t[u].m!=<span class="number">1</span>||t[u].a)<span class="built_in">pd</span>(u);</span><br><span class="line">	<span class="type">int</span> z=t[u].l+t[u].r&gt;&gt;<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=z)sum=(sum+<span class="built_in">q</span>(u&lt;&lt;<span class="number">1</span>,l,r))%p;</span><br><span class="line">	<span class="keyword">if</span>(r&gt;z) sum=(sum+<span class="built_in">q</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r))%p;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">b</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;opt;</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">			<span class="built_in">mu</span>(<span class="number">1</span>,x,y,k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">			<span class="built_in">au</span>(<span class="number">1</span>,x,y,k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">			cout&lt;&lt;<span class="built_in">q</span>(<span class="number">1</span>,x,y)&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h4 id="t5">T5</h4>
<details class="note info no-icon"><summary><p>工厂</p>
</summary>
<p>小明的叔叔是一家工厂的厂长。叔叔的工厂有 n 个车间，编号为 1～n。</p>
<p>管理工厂是很麻烦的事情，特别是在多次调整机器以及员工之后，统计总生产量更是难事。</p>
<p>第 i 个车间在刚开始的时候机器生产力为 ai，有 bi
个员工，那么这个车间的生产力就为ai*bi。</p>
<p>工厂的总生产力定义为所有车间的生产力之和。</p>
<p>接下来的 m 天，每天叔叔就会调整一段区间的车间。</p>
<p>有两种调整：</p>
<p>第一种，是对于一段区间[l,r]的每一个车间重新分配每个车间的工人数为
x。</p>
<p>第二种，是对于一段区间[l,r]的每一个车间增加机器生产力 x。</p>
<p>现在，小明的叔叔想知道每天调整之后工厂的生产量变为多少。</p>

</details>
<p>我们发现，这和 T4 很像，只是“加”变为了“覆盖”。</p>
<p>于是把“加” lazy-tag 变为“覆盖”的即可。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code(thanks to lqs)
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 400010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> esp 1e-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 999999999999999999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b,g) for(LL i=a;i&lt;=b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rem(i,a,b,g) for(LL i=a;i&gt;=b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> repn(i,a,b,g) for(LL i=a;i&lt;b;i+=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> remn(i,a,b,g) for(LL i=a;i&gt;b;i-=g)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;LL,LL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mkp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i128 __int128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (ls+1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lm (l+r&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rm (lm+1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(i128 &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i128 f=<span class="number">1</span>;</span><br><span class="line">	x=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writing</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">10</span>)<span class="built_in">writing</span>(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">		x=-x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">writing</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">LL n,q,s,t,d,a[N],b[N],ans[N],sa[N],sb[N],ta[N],tb[N];</span><br><span class="line">string op;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pu</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ans[x]=ans[ls]+ans[rs];</span><br><span class="line">	sa[x]=sa[ls]+sa[rs];</span><br><span class="line">	sb[x]=sb[ls]+sb[rs];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pd</span><span class="params">(LL x,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sa[ls]+=ta[x]*(lm-l+<span class="number">1</span>);</span><br><span class="line">	sa[rs]+=ta[x]*(r-rm+<span class="number">1</span>);</span><br><span class="line">	ta[ls]+=ta[x];</span><br><span class="line">	ta[rs]+=ta[x];</span><br><span class="line">	<span class="keyword">if</span>(tb[x])</span><br><span class="line">	&#123;</span><br><span class="line">		sb[ls]=tb[x]*(lm-l+<span class="number">1</span>);</span><br><span class="line">		sb[rs]=tb[x]*(r-rm+<span class="number">1</span>);</span><br><span class="line">		ans[ls]=tb[x]*sa[ls];</span><br><span class="line">		ans[rs]=tb[x]*sa[rs];</span><br><span class="line">		tb[ls]=tb[rs]=tb[x];</span><br><span class="line">		tb[x]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ans[ls]+=ta[x]*sb[ls];</span><br><span class="line">		ans[rs]+=ta[x]*sb[rs];</span><br><span class="line">	&#125;</span><br><span class="line">	ta[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bu</span><span class="params">(LL x,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">        ans[x]=a[l]*b[l];</span><br><span class="line">        sa[x]=a[l];</span><br><span class="line">		sb[x]=b[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bu</span>(ls,l,lm);</span><br><span class="line">	<span class="built_in">bu</span>(rs,rm,r);</span><br><span class="line">    <span class="built_in">pu</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">se</span><span class="params">(LL x,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t&lt;l||s&gt;r)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(s&lt;=l&amp;&amp;r&lt;=t)</span><br><span class="line">	&#123;</span><br><span class="line">		sb[x]=d*(r-l+<span class="number">1</span>);</span><br><span class="line">		ans[x]=d*sa[x];</span><br><span class="line">		tb[x]=d;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pd</span>(x,l,r);</span><br><span class="line">	<span class="built_in">se</span>(ls,l,lm);</span><br><span class="line">	<span class="built_in">se</span>(rs,rm,r);</span><br><span class="line">	<span class="built_in">pu</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(LL x,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t&lt;l||s&gt;r)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(s&lt;=l&amp;&amp;r&lt;=t)</span><br><span class="line">	&#123;</span><br><span class="line">		sa[x]+=d*(r-l+<span class="number">1</span>);</span><br><span class="line">		ans[x]+=d*sb[x];</span><br><span class="line">		ta[x]+=d;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pd</span>(x,l,r);</span><br><span class="line">	<span class="built_in">add</span>(ls,l,lm);</span><br><span class="line">	<span class="built_in">add</span>(rs,rm,r);</span><br><span class="line">	<span class="built_in">pu</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>)cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">	<span class="built_in">bu</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(q--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;op&gt;&gt;s&gt;&gt;t&gt;&gt;d;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="string">&quot;Set&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">se</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;ans[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h4 id="t6"><a href="https://www.luogu.com.cn/problem/CF600E">T6</a></h4>
<p>权值线段树 <span class="math inline">\(+\)</span> 线段树合并。</p>
<p>每个子树中的颜色，开一颗权值线段树，向上回溯时合并即可。</p>
<h4 id="t7"><a href="https://www.luogu.com.cn/problem/P1856">T7</a></h4>
<p>首先，需要离散化，而后处理时有两种思路：</p>
<div class="tabs" id="两种思路"><ul class="nav-tabs"><li class="tab"><a href="#两种思路-1">思路一</a></li><li class="tab"><a href="#两种思路-2">思路二</a></li></ul><div class="tab-content"><div class="tab-pane" id="两种思路-1"><p>用一棵线段树，所以有一点点思维难度。</p>
<p>从上向下扫描，每次遇到一条边，若为上边，则在线段树上此区间进行加操作，下边则在此区间进行减操作。与面积并时相似。这是横边。竖边则利用扫描线走过的距离乘横向距离即可。</p>
<p>可以参考<a href="https://www.luogu.com.cn/article/9cuyuf44">这篇题解</a>。</p></div><div class="tab-pane" id="两种思路-2"><p>思路一的思维难度在于，竖边的处理较为麻烦，那么我们就如法炮制，竖边也建一棵线段树处理。</p></div></div></div>
<h3 id="小结">小结</h3>
<p>其实线段树还有不少应用，限于篇幅只能列出一部分。</p>
<p>赛中一般不会出裸线段树，所以想到用线段树是一个重要环节。</p>
<p>剩余部分可以参见
OI-wiki，讲的很清晰。有时间或有需求也可以学习几种线段树变形（李超等）。</p>
<p>另，由于部分题目代码过于长或因为某题最好自己写代码以学习，所以我没有放。</p>
<h3 id="致谢">致谢</h3>
<p>我学校的信息学教练 zxc 以及不是我学校的一位教练
gtc，为此文提供了例题以及基础；</p>
<p>OI-wiki 线段树部分编写人员及 OI-wiki
建设者，为本文线段树合并部分提供了定义以及为扫描线提供动图讲解；</p>
<p>我之前的英语老师 Cally，为本博客风格提供建议；</p>
<p>同学 lqs、whl，为我改代码（T5，lqs），讲解 T4（whl）；</p>
<p>hexo、github以及 next，为本博客提供支持；</p>
<p>同学 lyh，帮我调弄 hexo；</p>
<p>洛谷，提供题目、上传图片、教会我 <span class="math inline">\(\LaTeX\)</span>；</p>
<p><span class="math inline">\(mathjax\)</span>，对本文提供 <span class="math inline">\(\LaTeX\)</span> 支持。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>重修：四边形不等式 DP</title>
    <url>/2024/05/20/%E9%87%8D%E4%BF%AE-%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8FDP/</url>
    <content><![CDATA[
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>DP</category>
        <category>DP 优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>学习笔记</tag>
        <tag>优化</tag>
        <tag>重修</tag>
      </tags>
  </entry>
  <entry>
    <title>CPPOM五月邀请赛各题题解</title>
    <url>/2024/04/29/CPPOM%E4%BA%94%E6%9C%88%E9%82%80%E8%AF%B7%E8%B5%9B-%E5%90%84%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>比赛尚未开始，将在结束后3天内写上题解。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>查漏补缺：状压 DP</title>
    <url>/2024/05/20/%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E7%8A%B6%E5%8E%8B-DP/</url>
    <content><![CDATA[
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>DP</category>
        <category>DP 优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>学习笔记</tag>
        <tag>优化</tag>
        <tag>查漏补缺</tag>
      </tags>
  </entry>
  <entry>
    <title>重修：数位统计 DP</title>
    <url>/2024/05/20/%E9%87%8D%E4%BF%AE-%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1DP/</url>
    <content><![CDATA[
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>DP</category>
        <category>DP 优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>学习笔记</tag>
        <tag>优化</tag>
        <tag>重修</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/04/18/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
</search>
